{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#mcp-python-sdk","title":"MCP Python SDK","text":"<p>The Model Context Protocol (MCP) allows applications to provide context for LLMs in a standardized way, separating the concerns of providing context from the actual LLM interaction.</p> <p>This Python SDK implements the full MCP specification, making it easy to:</p> <ul> <li>Build MCP servers that expose resources, prompts, and tools</li> <li>Create MCP clients that can connect to any MCP server</li> <li>Use standard transports like stdio, SSE, and Streamable HTTP</li> </ul> <p>If you want to read more about the specification, please visit the MCP documentation.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<p>Here's a simple MCP server that exposes a tool, resource, and prompt:</p> server.py<pre><code>from mcp.server.fastmcp import FastMCP\n\nmcp = FastMCP(\"Test Server\", json_response=True)\n\n\n@mcp.tool()\ndef add(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n\n\n@mcp.resource(\"greeting://{name}\")\ndef get_greeting(name: str) -&gt; str:\n    \"\"\"Get a personalized greeting\"\"\"\n    return f\"Hello, {name}!\"\n\n\n@mcp.prompt()\ndef greet_user(name: str, style: str = \"friendly\") -&gt; str:\n    \"\"\"Generate a greeting prompt\"\"\"\n    return f\"Write a {style} greeting for someone named {name}.\"\n\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"streamable-http\")\n</code></pre> <p>Run the server:</p> <pre><code>uv run --with mcp server.py\n</code></pre> <p>Then open the MCP Inspector and connect to <code>http://localhost:8000/mcp</code>:</p> <pre><code>npx -y @modelcontextprotocol/inspector\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Install the MCP SDK</li> <li>Learn concepts - understand the three primitives and architecture</li> <li>Explore authorization - add security to your servers</li> <li>Use low-level APIs - for advanced customization</li> </ol>"},{"location":"#api-reference","title":"API Reference","text":"<p>Full API documentation is available in the API Reference.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#mcp.ClientSession","title":"ClientSession","text":"<p>               Bases: <code>BaseSession[ClientRequest, ClientNotification, ClientResult, ServerRequest, ServerNotification]</code></p> Source code in <code>src/mcp/client/session.py</code> <pre><code>class ClientSession(\n    BaseSession[\n        types.ClientRequest,\n        types.ClientNotification,\n        types.ClientResult,\n        types.ServerRequest,\n        types.ServerNotification,\n    ]\n):\n    def __init__(\n        self,\n        read_stream: MemoryObjectReceiveStream[SessionMessage | Exception],\n        write_stream: MemoryObjectSendStream[SessionMessage],\n        read_timeout_seconds: timedelta | None = None,\n        sampling_callback: SamplingFnT | None = None,\n        elicitation_callback: ElicitationFnT | None = None,\n        list_roots_callback: ListRootsFnT | None = None,\n        logging_callback: LoggingFnT | None = None,\n        message_handler: MessageHandlerFnT | None = None,\n        client_info: types.Implementation | None = None,\n        *,\n        sampling_capabilities: types.SamplingCapability | None = None,\n        experimental_task_handlers: ExperimentalTaskHandlers | None = None,\n    ) -&gt; None:\n        super().__init__(\n            read_stream,\n            write_stream,\n            types.ServerRequest,\n            types.ServerNotification,\n            read_timeout_seconds=read_timeout_seconds,\n        )\n        self._client_info = client_info or DEFAULT_CLIENT_INFO\n        self._sampling_callback = sampling_callback or _default_sampling_callback\n        self._sampling_capabilities = sampling_capabilities\n        self._elicitation_callback = elicitation_callback or _default_elicitation_callback\n        self._list_roots_callback = list_roots_callback or _default_list_roots_callback\n        self._logging_callback = logging_callback or _default_logging_callback\n        self._message_handler = message_handler or _default_message_handler\n        self._tool_output_schemas: dict[str, dict[str, Any] | None] = {}\n        self._server_capabilities: types.ServerCapabilities | None = None\n        self._experimental_features: ExperimentalClientFeatures | None = None\n\n        # Experimental: Task handlers (use defaults if not provided)\n        self._task_handlers = experimental_task_handlers or ExperimentalTaskHandlers()\n\n    async def initialize(self) -&gt; types.InitializeResult:\n        sampling = (\n            (self._sampling_capabilities or types.SamplingCapability())\n            if self._sampling_callback is not _default_sampling_callback\n            else None\n        )\n        elicitation = (\n            types.ElicitationCapability(\n                form=types.FormElicitationCapability(),\n                url=types.UrlElicitationCapability(),\n            )\n            if self._elicitation_callback is not _default_elicitation_callback\n            else None\n        )\n        roots = (\n            # TODO: Should this be based on whether we\n            # _will_ send notifications, or only whether\n            # they're supported?\n            types.RootsCapability(listChanged=True)\n            if self._list_roots_callback is not _default_list_roots_callback\n            else None\n        )\n\n        result = await self.send_request(\n            types.ClientRequest(\n                types.InitializeRequest(\n                    params=types.InitializeRequestParams(\n                        protocolVersion=types.LATEST_PROTOCOL_VERSION,\n                        capabilities=types.ClientCapabilities(\n                            sampling=sampling,\n                            elicitation=elicitation,\n                            experimental=None,\n                            roots=roots,\n                            tasks=self._task_handlers.build_capability(),\n                        ),\n                        clientInfo=self._client_info,\n                    ),\n                )\n            ),\n            types.InitializeResult,\n        )\n\n        if result.protocolVersion not in SUPPORTED_PROTOCOL_VERSIONS:\n            raise RuntimeError(f\"Unsupported protocol version from the server: {result.protocolVersion}\")\n\n        self._server_capabilities = result.capabilities\n\n        await self.send_notification(types.ClientNotification(types.InitializedNotification()))\n\n        return result\n\n    def get_server_capabilities(self) -&gt; types.ServerCapabilities | None:\n        \"\"\"Return the server capabilities received during initialization.\n\n        Returns None if the session has not been initialized yet.\n        \"\"\"\n        return self._server_capabilities\n\n    @property\n    def experimental(self) -&gt; ExperimentalClientFeatures:\n        \"\"\"Experimental APIs for tasks and other features.\n\n        WARNING: These APIs are experimental and may change without notice.\n\n        Example:\n            status = await session.experimental.get_task(task_id)\n            result = await session.experimental.get_task_result(task_id, CallToolResult)\n        \"\"\"\n        if self._experimental_features is None:\n            self._experimental_features = ExperimentalClientFeatures(self)\n        return self._experimental_features\n\n    async def send_ping(self) -&gt; types.EmptyResult:\n        \"\"\"Send a ping request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(types.PingRequest()),\n            types.EmptyResult,\n        )\n\n    async def send_progress_notification(\n        self,\n        progress_token: str | int,\n        progress: float,\n        total: float | None = None,\n        message: str | None = None,\n    ) -&gt; None:\n        \"\"\"Send a progress notification.\"\"\"\n        await self.send_notification(\n            types.ClientNotification(\n                types.ProgressNotification(\n                    params=types.ProgressNotificationParams(\n                        progressToken=progress_token,\n                        progress=progress,\n                        total=total,\n                        message=message,\n                    ),\n                ),\n            )\n        )\n\n    async def set_logging_level(self, level: types.LoggingLevel) -&gt; types.EmptyResult:\n        \"\"\"Send a logging/setLevel request.\"\"\"\n        return await self.send_request(  # pragma: no cover\n            types.ClientRequest(\n                types.SetLevelRequest(\n                    params=types.SetLevelRequestParams(level=level),\n                )\n            ),\n            types.EmptyResult,\n        )\n\n    @overload\n    @deprecated(\"Use list_resources(params=PaginatedRequestParams(...)) instead\")\n    async def list_resources(self, cursor: str | None) -&gt; types.ListResourcesResult: ...\n\n    @overload\n    async def list_resources(self, *, params: types.PaginatedRequestParams | None) -&gt; types.ListResourcesResult: ...\n\n    @overload\n    async def list_resources(self) -&gt; types.ListResourcesResult: ...\n\n    async def list_resources(\n        self,\n        cursor: str | None = None,\n        *,\n        params: types.PaginatedRequestParams | None = None,\n    ) -&gt; types.ListResourcesResult:\n        \"\"\"Send a resources/list request.\n\n        Args:\n            cursor: Simple cursor string for pagination (deprecated, use params instead)\n            params: Full pagination parameters including cursor and any future fields\n        \"\"\"\n        if params is not None and cursor is not None:\n            raise ValueError(\"Cannot specify both cursor and params\")\n\n        if params is not None:\n            request_params = params\n        elif cursor is not None:\n            request_params = types.PaginatedRequestParams(cursor=cursor)\n        else:\n            request_params = None\n\n        return await self.send_request(\n            types.ClientRequest(types.ListResourcesRequest(params=request_params)),\n            types.ListResourcesResult,\n        )\n\n    @overload\n    @deprecated(\"Use list_resource_templates(params=PaginatedRequestParams(...)) instead\")\n    async def list_resource_templates(self, cursor: str | None) -&gt; types.ListResourceTemplatesResult: ...\n\n    @overload\n    async def list_resource_templates(\n        self, *, params: types.PaginatedRequestParams | None\n    ) -&gt; types.ListResourceTemplatesResult: ...\n\n    @overload\n    async def list_resource_templates(self) -&gt; types.ListResourceTemplatesResult: ...\n\n    async def list_resource_templates(\n        self,\n        cursor: str | None = None,\n        *,\n        params: types.PaginatedRequestParams | None = None,\n    ) -&gt; types.ListResourceTemplatesResult:\n        \"\"\"Send a resources/templates/list request.\n\n        Args:\n            cursor: Simple cursor string for pagination (deprecated, use params instead)\n            params: Full pagination parameters including cursor and any future fields\n        \"\"\"\n        if params is not None and cursor is not None:\n            raise ValueError(\"Cannot specify both cursor and params\")\n\n        if params is not None:\n            request_params = params\n        elif cursor is not None:\n            request_params = types.PaginatedRequestParams(cursor=cursor)\n        else:\n            request_params = None\n\n        return await self.send_request(\n            types.ClientRequest(types.ListResourceTemplatesRequest(params=request_params)),\n            types.ListResourceTemplatesResult,\n        )\n\n    async def read_resource(self, uri: AnyUrl) -&gt; types.ReadResourceResult:\n        \"\"\"Send a resources/read request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.ReadResourceRequest(\n                    params=types.ReadResourceRequestParams(uri=uri),\n                )\n            ),\n            types.ReadResourceResult,\n        )\n\n    async def subscribe_resource(self, uri: AnyUrl) -&gt; types.EmptyResult:\n        \"\"\"Send a resources/subscribe request.\"\"\"\n        return await self.send_request(  # pragma: no cover\n            types.ClientRequest(\n                types.SubscribeRequest(\n                    params=types.SubscribeRequestParams(uri=uri),\n                )\n            ),\n            types.EmptyResult,\n        )\n\n    async def unsubscribe_resource(self, uri: AnyUrl) -&gt; types.EmptyResult:\n        \"\"\"Send a resources/unsubscribe request.\"\"\"\n        return await self.send_request(  # pragma: no cover\n            types.ClientRequest(\n                types.UnsubscribeRequest(\n                    params=types.UnsubscribeRequestParams(uri=uri),\n                )\n            ),\n            types.EmptyResult,\n        )\n\n    async def call_tool(\n        self,\n        name: str,\n        arguments: dict[str, Any] | None = None,\n        read_timeout_seconds: timedelta | None = None,\n        progress_callback: ProgressFnT | None = None,\n        *,\n        meta: dict[str, Any] | None = None,\n    ) -&gt; types.CallToolResult:\n        \"\"\"Send a tools/call request with optional progress callback support.\"\"\"\n\n        _meta: types.RequestParams.Meta | None = None\n        if meta is not None:\n            _meta = types.RequestParams.Meta(**meta)\n\n        result = await self.send_request(\n            types.ClientRequest(\n                types.CallToolRequest(\n                    params=types.CallToolRequestParams(name=name, arguments=arguments, _meta=_meta),\n                )\n            ),\n            types.CallToolResult,\n            request_read_timeout_seconds=read_timeout_seconds,\n            progress_callback=progress_callback,\n        )\n\n        if not result.isError:\n            await self._validate_tool_result(name, result)\n\n        return result\n\n    async def _validate_tool_result(self, name: str, result: types.CallToolResult) -&gt; None:\n        \"\"\"Validate the structured content of a tool result against its output schema.\"\"\"\n        if name not in self._tool_output_schemas:\n            # refresh output schema cache\n            await self.list_tools()\n\n        output_schema = None\n        if name in self._tool_output_schemas:\n            output_schema = self._tool_output_schemas.get(name)\n        else:\n            logger.warning(f\"Tool {name} not listed by server, cannot validate any structured content\")\n\n        if output_schema is not None:\n            from jsonschema import SchemaError, ValidationError, validate\n\n            if result.structuredContent is None:\n                raise RuntimeError(\n                    f\"Tool {name} has an output schema but did not return structured content\"\n                )  # pragma: no cover\n            try:\n                validate(result.structuredContent, output_schema)\n            except ValidationError as e:\n                raise RuntimeError(f\"Invalid structured content returned by tool {name}: {e}\")  # pragma: no cover\n            except SchemaError as e:  # pragma: no cover\n                raise RuntimeError(f\"Invalid schema for tool {name}: {e}\")  # pragma: no cover\n\n    @overload\n    @deprecated(\"Use list_prompts(params=PaginatedRequestParams(...)) instead\")\n    async def list_prompts(self, cursor: str | None) -&gt; types.ListPromptsResult: ...\n\n    @overload\n    async def list_prompts(self, *, params: types.PaginatedRequestParams | None) -&gt; types.ListPromptsResult: ...\n\n    @overload\n    async def list_prompts(self) -&gt; types.ListPromptsResult: ...\n\n    async def list_prompts(\n        self,\n        cursor: str | None = None,\n        *,\n        params: types.PaginatedRequestParams | None = None,\n    ) -&gt; types.ListPromptsResult:\n        \"\"\"Send a prompts/list request.\n\n        Args:\n            cursor: Simple cursor string for pagination (deprecated, use params instead)\n            params: Full pagination parameters including cursor and any future fields\n        \"\"\"\n        if params is not None and cursor is not None:\n            raise ValueError(\"Cannot specify both cursor and params\")\n\n        if params is not None:\n            request_params = params\n        elif cursor is not None:\n            request_params = types.PaginatedRequestParams(cursor=cursor)\n        else:\n            request_params = None\n\n        return await self.send_request(\n            types.ClientRequest(types.ListPromptsRequest(params=request_params)),\n            types.ListPromptsResult,\n        )\n\n    async def get_prompt(self, name: str, arguments: dict[str, str] | None = None) -&gt; types.GetPromptResult:\n        \"\"\"Send a prompts/get request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.GetPromptRequest(\n                    params=types.GetPromptRequestParams(name=name, arguments=arguments),\n                )\n            ),\n            types.GetPromptResult,\n        )\n\n    async def complete(\n        self,\n        ref: types.ResourceTemplateReference | types.PromptReference,\n        argument: dict[str, str],\n        context_arguments: dict[str, str] | None = None,\n    ) -&gt; types.CompleteResult:\n        \"\"\"Send a completion/complete request.\"\"\"\n        context = None\n        if context_arguments is not None:\n            context = types.CompletionContext(arguments=context_arguments)\n\n        return await self.send_request(\n            types.ClientRequest(\n                types.CompleteRequest(\n                    params=types.CompleteRequestParams(\n                        ref=ref,\n                        argument=types.CompletionArgument(**argument),\n                        context=context,\n                    ),\n                )\n            ),\n            types.CompleteResult,\n        )\n\n    @overload\n    @deprecated(\"Use list_tools(params=PaginatedRequestParams(...)) instead\")\n    async def list_tools(self, cursor: str | None) -&gt; types.ListToolsResult: ...\n\n    @overload\n    async def list_tools(self, *, params: types.PaginatedRequestParams | None) -&gt; types.ListToolsResult: ...\n\n    @overload\n    async def list_tools(self) -&gt; types.ListToolsResult: ...\n\n    async def list_tools(\n        self,\n        cursor: str | None = None,\n        *,\n        params: types.PaginatedRequestParams | None = None,\n    ) -&gt; types.ListToolsResult:\n        \"\"\"Send a tools/list request.\n\n        Args:\n            cursor: Simple cursor string for pagination (deprecated, use params instead)\n            params: Full pagination parameters including cursor and any future fields\n        \"\"\"\n        if params is not None and cursor is not None:\n            raise ValueError(\"Cannot specify both cursor and params\")\n\n        if params is not None:\n            request_params = params\n        elif cursor is not None:\n            request_params = types.PaginatedRequestParams(cursor=cursor)\n        else:\n            request_params = None\n\n        result = await self.send_request(\n            types.ClientRequest(types.ListToolsRequest(params=request_params)),\n            types.ListToolsResult,\n        )\n\n        # Cache tool output schemas for future validation\n        # Note: don't clear the cache, as we may be using a cursor\n        for tool in result.tools:\n            self._tool_output_schemas[tool.name] = tool.outputSchema\n\n        return result\n\n    async def send_roots_list_changed(self) -&gt; None:  # pragma: no cover\n        \"\"\"Send a roots/list_changed notification.\"\"\"\n        await self.send_notification(types.ClientNotification(types.RootsListChangedNotification()))\n\n    async def _received_request(self, responder: RequestResponder[types.ServerRequest, types.ClientResult]) -&gt; None:\n        ctx = RequestContext[ClientSession, Any](\n            request_id=responder.request_id,\n            meta=responder.request_meta,\n            session=self,\n            lifespan_context=None,\n        )\n\n        # Delegate to experimental task handler if applicable\n        if self._task_handlers.handles_request(responder.request):\n            with responder:\n                await self._task_handlers.handle_request(ctx, responder)\n            return None\n\n        # Core request handling\n        match responder.request.root:\n            case types.CreateMessageRequest(params=params):\n                with responder:\n                    # Check if this is a task-augmented request\n                    if params.task is not None:\n                        response = await self._task_handlers.augmented_sampling(ctx, params, params.task)\n                    else:\n                        response = await self._sampling_callback(ctx, params)\n                    client_response = ClientResponse.validate_python(response)\n                    await responder.respond(client_response)\n\n            case types.ElicitRequest(params=params):\n                with responder:\n                    # Check if this is a task-augmented request\n                    if params.task is not None:\n                        response = await self._task_handlers.augmented_elicitation(ctx, params, params.task)\n                    else:\n                        response = await self._elicitation_callback(ctx, params)\n                    client_response = ClientResponse.validate_python(response)\n                    await responder.respond(client_response)\n\n            case types.ListRootsRequest():\n                with responder:\n                    response = await self._list_roots_callback(ctx)\n                    client_response = ClientResponse.validate_python(response)\n                    await responder.respond(client_response)\n\n            case types.PingRequest():  # pragma: no cover\n                with responder:\n                    return await responder.respond(types.ClientResult(root=types.EmptyResult()))\n\n            case _:  # pragma: no cover\n                pass  # Task requests handled above by _task_handlers\n\n        return None\n\n    async def _handle_incoming(\n        self,\n        req: RequestResponder[types.ServerRequest, types.ClientResult] | types.ServerNotification | Exception,\n    ) -&gt; None:\n        \"\"\"Handle incoming messages by forwarding to the message handler.\"\"\"\n        await self._message_handler(req)\n\n    async def _received_notification(self, notification: types.ServerNotification) -&gt; None:\n        \"\"\"Handle notifications from the server.\"\"\"\n        # Process specific notification types\n        match notification.root:\n            case types.LoggingMessageNotification(params=params):\n                await self._logging_callback(params)\n            case types.ElicitCompleteNotification(params=params):\n                # Handle elicitation completion notification\n                # Clients MAY use this to retry requests or update UI\n                # The notification contains the elicitationId of the completed elicitation\n                pass\n            case _:\n                pass\n</code></pre>"},{"location":"api/#mcp.ClientSession.get_server_capabilities","title":"get_server_capabilities","text":"<pre><code>get_server_capabilities() -&gt; ServerCapabilities | None\n</code></pre> <p>Return the server capabilities received during initialization.</p> <p>Returns None if the session has not been initialized yet.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>def get_server_capabilities(self) -&gt; types.ServerCapabilities | None:\n    \"\"\"Return the server capabilities received during initialization.\n\n    Returns None if the session has not been initialized yet.\n    \"\"\"\n    return self._server_capabilities\n</code></pre>"},{"location":"api/#mcp.ClientSession.experimental","title":"experimental  <code>property</code>","text":"<pre><code>experimental: ExperimentalClientFeatures\n</code></pre> <p>Experimental APIs for tasks and other features.</p> <p>WARNING: These APIs are experimental and may change without notice.</p> Example <p>status = await session.experimental.get_task(task_id) result = await session.experimental.get_task_result(task_id, CallToolResult)</p>"},{"location":"api/#mcp.ClientSession.send_ping","title":"send_ping  <code>async</code>","text":"<pre><code>send_ping() -&gt; EmptyResult\n</code></pre> <p>Send a ping request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def send_ping(self) -&gt; types.EmptyResult:\n    \"\"\"Send a ping request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(types.PingRequest()),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.send_progress_notification","title":"send_progress_notification  <code>async</code>","text":"<pre><code>send_progress_notification(\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n) -&gt; None\n</code></pre> <p>Send a progress notification.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def send_progress_notification(\n    self,\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n) -&gt; None:\n    \"\"\"Send a progress notification.\"\"\"\n    await self.send_notification(\n        types.ClientNotification(\n            types.ProgressNotification(\n                params=types.ProgressNotificationParams(\n                    progressToken=progress_token,\n                    progress=progress,\n                    total=total,\n                    message=message,\n                ),\n            ),\n        )\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.set_logging_level","title":"set_logging_level  <code>async</code>","text":"<pre><code>set_logging_level(level: LoggingLevel) -&gt; EmptyResult\n</code></pre> <p>Send a logging/setLevel request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def set_logging_level(self, level: types.LoggingLevel) -&gt; types.EmptyResult:\n    \"\"\"Send a logging/setLevel request.\"\"\"\n    return await self.send_request(  # pragma: no cover\n        types.ClientRequest(\n            types.SetLevelRequest(\n                params=types.SetLevelRequestParams(level=level),\n            )\n        ),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.list_resources","title":"list_resources  <code>async</code>","text":"<pre><code>list_resources(cursor: str | None) -&gt; ListResourcesResult\n</code></pre><pre><code>list_resources(\n    *, params: PaginatedRequestParams | None\n) -&gt; ListResourcesResult\n</code></pre><pre><code>list_resources() -&gt; ListResourcesResult\n</code></pre> <pre><code>list_resources(\n    cursor: str | None = None,\n    *,\n    params: PaginatedRequestParams | None = None\n) -&gt; ListResourcesResult\n</code></pre> <p>Send a resources/list request.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>str | None</code> <p>Simple cursor string for pagination (deprecated, use params instead)</p> <code>None</code> <code>params</code> <code>PaginatedRequestParams | None</code> <p>Full pagination parameters including cursor and any future fields</p> <code>None</code> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def list_resources(\n    self,\n    cursor: str | None = None,\n    *,\n    params: types.PaginatedRequestParams | None = None,\n) -&gt; types.ListResourcesResult:\n    \"\"\"Send a resources/list request.\n\n    Args:\n        cursor: Simple cursor string for pagination (deprecated, use params instead)\n        params: Full pagination parameters including cursor and any future fields\n    \"\"\"\n    if params is not None and cursor is not None:\n        raise ValueError(\"Cannot specify both cursor and params\")\n\n    if params is not None:\n        request_params = params\n    elif cursor is not None:\n        request_params = types.PaginatedRequestParams(cursor=cursor)\n    else:\n        request_params = None\n\n    return await self.send_request(\n        types.ClientRequest(types.ListResourcesRequest(params=request_params)),\n        types.ListResourcesResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.list_resource_templates","title":"list_resource_templates  <code>async</code>","text":"<pre><code>list_resource_templates(\n    cursor: str | None,\n) -&gt; ListResourceTemplatesResult\n</code></pre><pre><code>list_resource_templates(\n    *, params: PaginatedRequestParams | None\n) -&gt; ListResourceTemplatesResult\n</code></pre><pre><code>list_resource_templates() -&gt; ListResourceTemplatesResult\n</code></pre> <pre><code>list_resource_templates(\n    cursor: str | None = None,\n    *,\n    params: PaginatedRequestParams | None = None\n) -&gt; ListResourceTemplatesResult\n</code></pre> <p>Send a resources/templates/list request.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>str | None</code> <p>Simple cursor string for pagination (deprecated, use params instead)</p> <code>None</code> <code>params</code> <code>PaginatedRequestParams | None</code> <p>Full pagination parameters including cursor and any future fields</p> <code>None</code> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def list_resource_templates(\n    self,\n    cursor: str | None = None,\n    *,\n    params: types.PaginatedRequestParams | None = None,\n) -&gt; types.ListResourceTemplatesResult:\n    \"\"\"Send a resources/templates/list request.\n\n    Args:\n        cursor: Simple cursor string for pagination (deprecated, use params instead)\n        params: Full pagination parameters including cursor and any future fields\n    \"\"\"\n    if params is not None and cursor is not None:\n        raise ValueError(\"Cannot specify both cursor and params\")\n\n    if params is not None:\n        request_params = params\n    elif cursor is not None:\n        request_params = types.PaginatedRequestParams(cursor=cursor)\n    else:\n        request_params = None\n\n    return await self.send_request(\n        types.ClientRequest(types.ListResourceTemplatesRequest(params=request_params)),\n        types.ListResourceTemplatesResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.read_resource","title":"read_resource  <code>async</code>","text":"<pre><code>read_resource(uri: AnyUrl) -&gt; ReadResourceResult\n</code></pre> <p>Send a resources/read request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def read_resource(self, uri: AnyUrl) -&gt; types.ReadResourceResult:\n    \"\"\"Send a resources/read request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.ReadResourceRequest(\n                params=types.ReadResourceRequestParams(uri=uri),\n            )\n        ),\n        types.ReadResourceResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.subscribe_resource","title":"subscribe_resource  <code>async</code>","text":"<pre><code>subscribe_resource(uri: AnyUrl) -&gt; EmptyResult\n</code></pre> <p>Send a resources/subscribe request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def subscribe_resource(self, uri: AnyUrl) -&gt; types.EmptyResult:\n    \"\"\"Send a resources/subscribe request.\"\"\"\n    return await self.send_request(  # pragma: no cover\n        types.ClientRequest(\n            types.SubscribeRequest(\n                params=types.SubscribeRequestParams(uri=uri),\n            )\n        ),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.unsubscribe_resource","title":"unsubscribe_resource  <code>async</code>","text":"<pre><code>unsubscribe_resource(uri: AnyUrl) -&gt; EmptyResult\n</code></pre> <p>Send a resources/unsubscribe request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def unsubscribe_resource(self, uri: AnyUrl) -&gt; types.EmptyResult:\n    \"\"\"Send a resources/unsubscribe request.\"\"\"\n    return await self.send_request(  # pragma: no cover\n        types.ClientRequest(\n            types.UnsubscribeRequest(\n                params=types.UnsubscribeRequestParams(uri=uri),\n            )\n        ),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str,\n    arguments: dict[str, Any] | None = None,\n    read_timeout_seconds: timedelta | None = None,\n    progress_callback: ProgressFnT | None = None,\n    *,\n    meta: dict[str, Any] | None = None\n) -&gt; CallToolResult\n</code></pre> <p>Send a tools/call request with optional progress callback support.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def call_tool(\n    self,\n    name: str,\n    arguments: dict[str, Any] | None = None,\n    read_timeout_seconds: timedelta | None = None,\n    progress_callback: ProgressFnT | None = None,\n    *,\n    meta: dict[str, Any] | None = None,\n) -&gt; types.CallToolResult:\n    \"\"\"Send a tools/call request with optional progress callback support.\"\"\"\n\n    _meta: types.RequestParams.Meta | None = None\n    if meta is not None:\n        _meta = types.RequestParams.Meta(**meta)\n\n    result = await self.send_request(\n        types.ClientRequest(\n            types.CallToolRequest(\n                params=types.CallToolRequestParams(name=name, arguments=arguments, _meta=_meta),\n            )\n        ),\n        types.CallToolResult,\n        request_read_timeout_seconds=read_timeout_seconds,\n        progress_callback=progress_callback,\n    )\n\n    if not result.isError:\n        await self._validate_tool_result(name, result)\n\n    return result\n</code></pre>"},{"location":"api/#mcp.ClientSession.list_prompts","title":"list_prompts  <code>async</code>","text":"<pre><code>list_prompts(cursor: str | None) -&gt; ListPromptsResult\n</code></pre><pre><code>list_prompts(\n    *, params: PaginatedRequestParams | None\n) -&gt; ListPromptsResult\n</code></pre><pre><code>list_prompts() -&gt; ListPromptsResult\n</code></pre> <pre><code>list_prompts(\n    cursor: str | None = None,\n    *,\n    params: PaginatedRequestParams | None = None\n) -&gt; ListPromptsResult\n</code></pre> <p>Send a prompts/list request.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>str | None</code> <p>Simple cursor string for pagination (deprecated, use params instead)</p> <code>None</code> <code>params</code> <code>PaginatedRequestParams | None</code> <p>Full pagination parameters including cursor and any future fields</p> <code>None</code> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def list_prompts(\n    self,\n    cursor: str | None = None,\n    *,\n    params: types.PaginatedRequestParams | None = None,\n) -&gt; types.ListPromptsResult:\n    \"\"\"Send a prompts/list request.\n\n    Args:\n        cursor: Simple cursor string for pagination (deprecated, use params instead)\n        params: Full pagination parameters including cursor and any future fields\n    \"\"\"\n    if params is not None and cursor is not None:\n        raise ValueError(\"Cannot specify both cursor and params\")\n\n    if params is not None:\n        request_params = params\n    elif cursor is not None:\n        request_params = types.PaginatedRequestParams(cursor=cursor)\n    else:\n        request_params = None\n\n    return await self.send_request(\n        types.ClientRequest(types.ListPromptsRequest(params=request_params)),\n        types.ListPromptsResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.get_prompt","title":"get_prompt  <code>async</code>","text":"<pre><code>get_prompt(\n    name: str, arguments: dict[str, str] | None = None\n) -&gt; GetPromptResult\n</code></pre> <p>Send a prompts/get request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def get_prompt(self, name: str, arguments: dict[str, str] | None = None) -&gt; types.GetPromptResult:\n    \"\"\"Send a prompts/get request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.GetPromptRequest(\n                params=types.GetPromptRequestParams(name=name, arguments=arguments),\n            )\n        ),\n        types.GetPromptResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.complete","title":"complete  <code>async</code>","text":"<pre><code>complete(\n    ref: ResourceTemplateReference | PromptReference,\n    argument: dict[str, str],\n    context_arguments: dict[str, str] | None = None,\n) -&gt; CompleteResult\n</code></pre> <p>Send a completion/complete request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def complete(\n    self,\n    ref: types.ResourceTemplateReference | types.PromptReference,\n    argument: dict[str, str],\n    context_arguments: dict[str, str] | None = None,\n) -&gt; types.CompleteResult:\n    \"\"\"Send a completion/complete request.\"\"\"\n    context = None\n    if context_arguments is not None:\n        context = types.CompletionContext(arguments=context_arguments)\n\n    return await self.send_request(\n        types.ClientRequest(\n            types.CompleteRequest(\n                params=types.CompleteRequestParams(\n                    ref=ref,\n                    argument=types.CompletionArgument(**argument),\n                    context=context,\n                ),\n            )\n        ),\n        types.CompleteResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.list_tools","title":"list_tools  <code>async</code>","text":"<pre><code>list_tools(cursor: str | None) -&gt; ListToolsResult\n</code></pre><pre><code>list_tools(\n    *, params: PaginatedRequestParams | None\n) -&gt; ListToolsResult\n</code></pre><pre><code>list_tools() -&gt; ListToolsResult\n</code></pre> <pre><code>list_tools(\n    cursor: str | None = None,\n    *,\n    params: PaginatedRequestParams | None = None\n) -&gt; ListToolsResult\n</code></pre> <p>Send a tools/list request.</p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>str | None</code> <p>Simple cursor string for pagination (deprecated, use params instead)</p> <code>None</code> <code>params</code> <code>PaginatedRequestParams | None</code> <p>Full pagination parameters including cursor and any future fields</p> <code>None</code> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def list_tools(\n    self,\n    cursor: str | None = None,\n    *,\n    params: types.PaginatedRequestParams | None = None,\n) -&gt; types.ListToolsResult:\n    \"\"\"Send a tools/list request.\n\n    Args:\n        cursor: Simple cursor string for pagination (deprecated, use params instead)\n        params: Full pagination parameters including cursor and any future fields\n    \"\"\"\n    if params is not None and cursor is not None:\n        raise ValueError(\"Cannot specify both cursor and params\")\n\n    if params is not None:\n        request_params = params\n    elif cursor is not None:\n        request_params = types.PaginatedRequestParams(cursor=cursor)\n    else:\n        request_params = None\n\n    result = await self.send_request(\n        types.ClientRequest(types.ListToolsRequest(params=request_params)),\n        types.ListToolsResult,\n    )\n\n    # Cache tool output schemas for future validation\n    # Note: don't clear the cache, as we may be using a cursor\n    for tool in result.tools:\n        self._tool_output_schemas[tool.name] = tool.outputSchema\n\n    return result\n</code></pre>"},{"location":"api/#mcp.ClientSession.send_roots_list_changed","title":"send_roots_list_changed  <code>async</code>","text":"<pre><code>send_roots_list_changed() -&gt; None\n</code></pre> <p>Send a roots/list_changed notification.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def send_roots_list_changed(self) -&gt; None:  # pragma: no cover\n    \"\"\"Send a roots/list_changed notification.\"\"\"\n    await self.send_notification(types.ClientNotification(types.RootsListChangedNotification()))\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup","title":"ClientSessionGroup","text":"<p>Client for managing connections to multiple MCP servers.</p> <p>This class is responsible for encapsulating management of server connections. It aggregates tools, resources, and prompts from all connected servers.</p> <p>For auxiliary handlers, such as resource subscription, this is delegated to the client and can be accessed via the session.</p> Example Usage <p>name_fn = lambda name, server_info: f\"{(server_info.name)}_{name}\" async with ClientSessionGroup(component_name_hook=name_fn) as group:     for server_param in server_params:         await group.connect_to_server(server_param)     ...</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>class ClientSessionGroup:\n    \"\"\"Client for managing connections to multiple MCP servers.\n\n    This class is responsible for encapsulating management of server connections.\n    It aggregates tools, resources, and prompts from all connected servers.\n\n    For auxiliary handlers, such as resource subscription, this is delegated to\n    the client and can be accessed via the session.\n\n    Example Usage:\n        name_fn = lambda name, server_info: f\"{(server_info.name)}_{name}\"\n        async with ClientSessionGroup(component_name_hook=name_fn) as group:\n            for server_param in server_params:\n                await group.connect_to_server(server_param)\n            ...\n\n    \"\"\"\n\n    class _ComponentNames(BaseModel):\n        \"\"\"Used for reverse index to find components.\"\"\"\n\n        prompts: set[str] = set()\n        resources: set[str] = set()\n        tools: set[str] = set()\n\n    # Standard MCP components.\n    _prompts: dict[str, types.Prompt]\n    _resources: dict[str, types.Resource]\n    _tools: dict[str, types.Tool]\n\n    # Client-server connection management.\n    _sessions: dict[mcp.ClientSession, _ComponentNames]\n    _tool_to_session: dict[str, mcp.ClientSession]\n    _exit_stack: contextlib.AsyncExitStack\n    _session_exit_stacks: dict[mcp.ClientSession, contextlib.AsyncExitStack]\n\n    # Optional fn consuming (component_name, serverInfo) for custom names.\n    # This is provide a means to mitigate naming conflicts across servers.\n    # Example: (tool_name, serverInfo) =&gt; \"{result.serverInfo.name}.{tool_name}\"\n    _ComponentNameHook: TypeAlias = Callable[[str, types.Implementation], str]\n    _component_name_hook: _ComponentNameHook | None\n\n    def __init__(\n        self,\n        exit_stack: contextlib.AsyncExitStack | None = None,\n        component_name_hook: _ComponentNameHook | None = None,\n    ) -&gt; None:\n        \"\"\"Initializes the MCP client.\"\"\"\n\n        self._tools = {}\n        self._resources = {}\n        self._prompts = {}\n\n        self._sessions = {}\n        self._tool_to_session = {}\n        if exit_stack is None:\n            self._exit_stack = contextlib.AsyncExitStack()\n            self._owns_exit_stack = True\n        else:\n            self._exit_stack = exit_stack\n            self._owns_exit_stack = False\n        self._session_exit_stacks = {}\n        self._component_name_hook = component_name_hook\n\n    async def __aenter__(self) -&gt; Self:  # pragma: no cover\n        # Enter the exit stack only if we created it ourselves\n        if self._owns_exit_stack:\n            await self._exit_stack.__aenter__()\n        return self\n\n    async def __aexit__(\n        self,\n        _exc_type: type[BaseException] | None,\n        _exc_val: BaseException | None,\n        _exc_tb: TracebackType | None,\n    ) -&gt; bool | None:  # pragma: no cover\n        \"\"\"Closes session exit stacks and main exit stack upon completion.\"\"\"\n\n        # Only close the main exit stack if we created it\n        if self._owns_exit_stack:\n            await self._exit_stack.aclose()\n\n        # Concurrently close session stacks.\n        async with anyio.create_task_group() as tg:\n            for exit_stack in self._session_exit_stacks.values():\n                tg.start_soon(exit_stack.aclose)\n\n    @property\n    def sessions(self) -&gt; list[mcp.ClientSession]:\n        \"\"\"Returns the list of sessions being managed.\"\"\"\n        return list(self._sessions.keys())  # pragma: no cover\n\n    @property\n    def prompts(self) -&gt; dict[str, types.Prompt]:\n        \"\"\"Returns the prompts as a dictionary of names to prompts.\"\"\"\n        return self._prompts\n\n    @property\n    def resources(self) -&gt; dict[str, types.Resource]:\n        \"\"\"Returns the resources as a dictionary of names to resources.\"\"\"\n        return self._resources\n\n    @property\n    def tools(self) -&gt; dict[str, types.Tool]:\n        \"\"\"Returns the tools as a dictionary of names to tools.\"\"\"\n        return self._tools\n\n    @overload\n    async def call_tool(\n        self,\n        name: str,\n        arguments: dict[str, Any],\n        read_timeout_seconds: timedelta | None = None,\n        progress_callback: ProgressFnT | None = None,\n        *,\n        meta: dict[str, Any] | None = None,\n    ) -&gt; types.CallToolResult: ...\n\n    @overload\n    @deprecated(\"The 'args' parameter is deprecated. Use 'arguments' instead.\")\n    async def call_tool(\n        self,\n        name: str,\n        *,\n        args: dict[str, Any],\n        read_timeout_seconds: timedelta | None = None,\n        progress_callback: ProgressFnT | None = None,\n        meta: dict[str, Any] | None = None,\n    ) -&gt; types.CallToolResult: ...\n\n    async def call_tool(\n        self,\n        name: str,\n        arguments: dict[str, Any] | None = None,\n        read_timeout_seconds: timedelta | None = None,\n        progress_callback: ProgressFnT | None = None,\n        *,\n        meta: dict[str, Any] | None = None,\n        args: dict[str, Any] | None = None,\n    ) -&gt; types.CallToolResult:\n        \"\"\"Executes a tool given its name and arguments.\"\"\"\n        session = self._tool_to_session[name]\n        session_tool_name = self.tools[name].name\n        return await session.call_tool(\n            session_tool_name,\n            arguments if args is None else args,\n            read_timeout_seconds=read_timeout_seconds,\n            progress_callback=progress_callback,\n            meta=meta,\n        )\n\n    async def disconnect_from_server(self, session: mcp.ClientSession) -&gt; None:\n        \"\"\"Disconnects from a single MCP server.\"\"\"\n\n        session_known_for_components = session in self._sessions\n        session_known_for_stack = session in self._session_exit_stacks\n\n        if not session_known_for_components and not session_known_for_stack:\n            raise McpError(\n                types.ErrorData(\n                    code=types.INVALID_PARAMS,\n                    message=\"Provided session is not managed or already disconnected.\",\n                )\n            )\n\n        if session_known_for_components:  # pragma: no cover\n            component_names = self._sessions.pop(session)  # Pop from _sessions tracking\n\n            # Remove prompts associated with the session.\n            for name in component_names.prompts:\n                if name in self._prompts:\n                    del self._prompts[name]\n            # Remove resources associated with the session.\n            for name in component_names.resources:\n                if name in self._resources:\n                    del self._resources[name]\n            # Remove tools associated with the session.\n            for name in component_names.tools:\n                if name in self._tools:\n                    del self._tools[name]\n                if name in self._tool_to_session:\n                    del self._tool_to_session[name]\n\n        # Clean up the session's resources via its dedicated exit stack\n        if session_known_for_stack:\n            session_stack_to_close = self._session_exit_stacks.pop(session)  # pragma: no cover\n            await session_stack_to_close.aclose()  # pragma: no cover\n\n    async def connect_with_session(\n        self, server_info: types.Implementation, session: mcp.ClientSession\n    ) -&gt; mcp.ClientSession:\n        \"\"\"Connects to a single MCP server.\"\"\"\n        await self._aggregate_components(server_info, session)\n        return session\n\n    async def connect_to_server(\n        self,\n        server_params: ServerParameters,\n        session_params: ClientSessionParameters | None = None,\n    ) -&gt; mcp.ClientSession:\n        \"\"\"Connects to a single MCP server.\"\"\"\n        server_info, session = await self._establish_session(server_params, session_params or ClientSessionParameters())\n        return await self.connect_with_session(server_info, session)\n\n    async def _establish_session(\n        self,\n        server_params: ServerParameters,\n        session_params: ClientSessionParameters,\n    ) -&gt; tuple[types.Implementation, mcp.ClientSession]:\n        \"\"\"Establish a client session to an MCP server.\"\"\"\n\n        session_stack = contextlib.AsyncExitStack()\n        try:\n            # Create read and write streams that facilitate io with the server.\n            if isinstance(server_params, StdioServerParameters):\n                client = mcp.stdio_client(server_params)\n                read, write = await session_stack.enter_async_context(client)\n            elif isinstance(server_params, SseServerParameters):\n                client = sse_client(\n                    url=server_params.url,\n                    headers=server_params.headers,\n                    timeout=server_params.timeout,\n                    sse_read_timeout=server_params.sse_read_timeout,\n                )\n                read, write = await session_stack.enter_async_context(client)\n            else:\n                httpx_client = create_mcp_http_client(\n                    headers=server_params.headers,\n                    timeout=httpx.Timeout(\n                        server_params.timeout.total_seconds(),\n                        read=server_params.sse_read_timeout.total_seconds(),\n                    ),\n                )\n                await session_stack.enter_async_context(httpx_client)\n\n                client = streamable_http_client(\n                    url=server_params.url,\n                    http_client=httpx_client,\n                    terminate_on_close=server_params.terminate_on_close,\n                )\n                read, write, _ = await session_stack.enter_async_context(client)\n\n            session = await session_stack.enter_async_context(\n                mcp.ClientSession(\n                    read,\n                    write,\n                    read_timeout_seconds=session_params.read_timeout_seconds,\n                    sampling_callback=session_params.sampling_callback,\n                    elicitation_callback=session_params.elicitation_callback,\n                    list_roots_callback=session_params.list_roots_callback,\n                    logging_callback=session_params.logging_callback,\n                    message_handler=session_params.message_handler,\n                    client_info=session_params.client_info,\n                )\n            )\n\n            result = await session.initialize()\n\n            # Session successfully initialized.\n            # Store its stack and register the stack with the main group stack.\n            self._session_exit_stacks[session] = session_stack\n            # session_stack itself becomes a resource managed by the\n            # main _exit_stack.\n            await self._exit_stack.enter_async_context(session_stack)\n\n            return result.serverInfo, session\n        except Exception:  # pragma: no cover\n            # If anything during this setup fails, ensure the session-specific\n            # stack is closed.\n            await session_stack.aclose()\n            raise\n\n    async def _aggregate_components(self, server_info: types.Implementation, session: mcp.ClientSession) -&gt; None:\n        \"\"\"Aggregates prompts, resources, and tools from a given session.\"\"\"\n\n        # Create a reverse index so we can find all prompts, resources, and\n        # tools belonging to this session. Used for removing components from\n        # the session group via self.disconnect_from_server.\n        component_names = self._ComponentNames()\n\n        # Temporary components dicts. We do not want to modify the aggregate\n        # lists in case of an intermediate failure.\n        prompts_temp: dict[str, types.Prompt] = {}\n        resources_temp: dict[str, types.Resource] = {}\n        tools_temp: dict[str, types.Tool] = {}\n        tool_to_session_temp: dict[str, mcp.ClientSession] = {}\n\n        # Query the server for its prompts and aggregate to list.\n        try:\n            prompts = (await session.list_prompts()).prompts\n            for prompt in prompts:\n                name = self._component_name(prompt.name, server_info)\n                prompts_temp[name] = prompt\n                component_names.prompts.add(name)\n        except McpError as err:  # pragma: no cover\n            logging.warning(f\"Could not fetch prompts: {err}\")\n\n        # Query the server for its resources and aggregate to list.\n        try:\n            resources = (await session.list_resources()).resources\n            for resource in resources:\n                name = self._component_name(resource.name, server_info)\n                resources_temp[name] = resource\n                component_names.resources.add(name)\n        except McpError as err:  # pragma: no cover\n            logging.warning(f\"Could not fetch resources: {err}\")\n\n        # Query the server for its tools and aggregate to list.\n        try:\n            tools = (await session.list_tools()).tools\n            for tool in tools:\n                name = self._component_name(tool.name, server_info)\n                tools_temp[name] = tool\n                tool_to_session_temp[name] = session\n                component_names.tools.add(name)\n        except McpError as err:  # pragma: no cover\n            logging.warning(f\"Could not fetch tools: {err}\")\n\n        # Clean up exit stack for session if we couldn't retrieve anything\n        # from the server.\n        if not any((prompts_temp, resources_temp, tools_temp)):\n            del self._session_exit_stacks[session]  # pragma: no cover\n\n        # Check for duplicates.\n        matching_prompts = prompts_temp.keys() &amp; self._prompts.keys()\n        if matching_prompts:\n            raise McpError(  # pragma: no cover\n                types.ErrorData(\n                    code=types.INVALID_PARAMS,\n                    message=f\"{matching_prompts} already exist in group prompts.\",\n                )\n            )\n        matching_resources = resources_temp.keys() &amp; self._resources.keys()\n        if matching_resources:\n            raise McpError(  # pragma: no cover\n                types.ErrorData(\n                    code=types.INVALID_PARAMS,\n                    message=f\"{matching_resources} already exist in group resources.\",\n                )\n            )\n        matching_tools = tools_temp.keys() &amp; self._tools.keys()\n        if matching_tools:\n            raise McpError(\n                types.ErrorData(\n                    code=types.INVALID_PARAMS,\n                    message=f\"{matching_tools} already exist in group tools.\",\n                )\n            )\n\n        # Aggregate components.\n        self._sessions[session] = component_names\n        self._prompts.update(prompts_temp)\n        self._resources.update(resources_temp)\n        self._tools.update(tools_temp)\n        self._tool_to_session.update(tool_to_session_temp)\n\n    def _component_name(self, name: str, server_info: types.Implementation) -&gt; str:\n        if self._component_name_hook:\n            return self._component_name_hook(name, server_info)\n        return name\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.__init__","title":"__init__","text":"<pre><code>__init__(\n    exit_stack: AsyncExitStack | None = None,\n    component_name_hook: _ComponentNameHook | None = None,\n) -&gt; None\n</code></pre> <p>Initializes the MCP client.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>def __init__(\n    self,\n    exit_stack: contextlib.AsyncExitStack | None = None,\n    component_name_hook: _ComponentNameHook | None = None,\n) -&gt; None:\n    \"\"\"Initializes the MCP client.\"\"\"\n\n    self._tools = {}\n    self._resources = {}\n    self._prompts = {}\n\n    self._sessions = {}\n    self._tool_to_session = {}\n    if exit_stack is None:\n        self._exit_stack = contextlib.AsyncExitStack()\n        self._owns_exit_stack = True\n    else:\n        self._exit_stack = exit_stack\n        self._owns_exit_stack = False\n    self._session_exit_stacks = {}\n    self._component_name_hook = component_name_hook\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: TracebackType | None,\n) -&gt; bool | None\n</code></pre> <p>Closes session exit stacks and main exit stack upon completion.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def __aexit__(\n    self,\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: TracebackType | None,\n) -&gt; bool | None:  # pragma: no cover\n    \"\"\"Closes session exit stacks and main exit stack upon completion.\"\"\"\n\n    # Only close the main exit stack if we created it\n    if self._owns_exit_stack:\n        await self._exit_stack.aclose()\n\n    # Concurrently close session stacks.\n    async with anyio.create_task_group() as tg:\n        for exit_stack in self._session_exit_stacks.values():\n            tg.start_soon(exit_stack.aclose)\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.sessions","title":"sessions  <code>property</code>","text":"<pre><code>sessions: list[ClientSession]\n</code></pre> <p>Returns the list of sessions being managed.</p>"},{"location":"api/#mcp.ClientSessionGroup.prompts","title":"prompts  <code>property</code>","text":"<pre><code>prompts: dict[str, Prompt]\n</code></pre> <p>Returns the prompts as a dictionary of names to prompts.</p>"},{"location":"api/#mcp.ClientSessionGroup.resources","title":"resources  <code>property</code>","text":"<pre><code>resources: dict[str, Resource]\n</code></pre> <p>Returns the resources as a dictionary of names to resources.</p>"},{"location":"api/#mcp.ClientSessionGroup.tools","title":"tools  <code>property</code>","text":"<pre><code>tools: dict[str, Tool]\n</code></pre> <p>Returns the tools as a dictionary of names to tools.</p>"},{"location":"api/#mcp.ClientSessionGroup.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str,\n    arguments: dict[str, Any],\n    read_timeout_seconds: timedelta | None = None,\n    progress_callback: ProgressFnT | None = None,\n    *,\n    meta: dict[str, Any] | None = None\n) -&gt; CallToolResult\n</code></pre><pre><code>call_tool(\n    name: str,\n    *,\n    args: dict[str, Any],\n    read_timeout_seconds: timedelta | None = None,\n    progress_callback: ProgressFnT | None = None,\n    meta: dict[str, Any] | None = None\n) -&gt; CallToolResult\n</code></pre> <pre><code>call_tool(\n    name: str,\n    arguments: dict[str, Any] | None = None,\n    read_timeout_seconds: timedelta | None = None,\n    progress_callback: ProgressFnT | None = None,\n    *,\n    meta: dict[str, Any] | None = None,\n    args: dict[str, Any] | None = None\n) -&gt; CallToolResult\n</code></pre> <p>Executes a tool given its name and arguments.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def call_tool(\n    self,\n    name: str,\n    arguments: dict[str, Any] | None = None,\n    read_timeout_seconds: timedelta | None = None,\n    progress_callback: ProgressFnT | None = None,\n    *,\n    meta: dict[str, Any] | None = None,\n    args: dict[str, Any] | None = None,\n) -&gt; types.CallToolResult:\n    \"\"\"Executes a tool given its name and arguments.\"\"\"\n    session = self._tool_to_session[name]\n    session_tool_name = self.tools[name].name\n    return await session.call_tool(\n        session_tool_name,\n        arguments if args is None else args,\n        read_timeout_seconds=read_timeout_seconds,\n        progress_callback=progress_callback,\n        meta=meta,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.disconnect_from_server","title":"disconnect_from_server  <code>async</code>","text":"<pre><code>disconnect_from_server(session: ClientSession) -&gt; None\n</code></pre> <p>Disconnects from a single MCP server.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def disconnect_from_server(self, session: mcp.ClientSession) -&gt; None:\n    \"\"\"Disconnects from a single MCP server.\"\"\"\n\n    session_known_for_components = session in self._sessions\n    session_known_for_stack = session in self._session_exit_stacks\n\n    if not session_known_for_components and not session_known_for_stack:\n        raise McpError(\n            types.ErrorData(\n                code=types.INVALID_PARAMS,\n                message=\"Provided session is not managed or already disconnected.\",\n            )\n        )\n\n    if session_known_for_components:  # pragma: no cover\n        component_names = self._sessions.pop(session)  # Pop from _sessions tracking\n\n        # Remove prompts associated with the session.\n        for name in component_names.prompts:\n            if name in self._prompts:\n                del self._prompts[name]\n        # Remove resources associated with the session.\n        for name in component_names.resources:\n            if name in self._resources:\n                del self._resources[name]\n        # Remove tools associated with the session.\n        for name in component_names.tools:\n            if name in self._tools:\n                del self._tools[name]\n            if name in self._tool_to_session:\n                del self._tool_to_session[name]\n\n    # Clean up the session's resources via its dedicated exit stack\n    if session_known_for_stack:\n        session_stack_to_close = self._session_exit_stacks.pop(session)  # pragma: no cover\n        await session_stack_to_close.aclose()  # pragma: no cover\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.connect_with_session","title":"connect_with_session  <code>async</code>","text":"<pre><code>connect_with_session(\n    server_info: Implementation, session: ClientSession\n) -&gt; ClientSession\n</code></pre> <p>Connects to a single MCP server.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def connect_with_session(\n    self, server_info: types.Implementation, session: mcp.ClientSession\n) -&gt; mcp.ClientSession:\n    \"\"\"Connects to a single MCP server.\"\"\"\n    await self._aggregate_components(server_info, session)\n    return session\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.connect_to_server","title":"connect_to_server  <code>async</code>","text":"<pre><code>connect_to_server(\n    server_params: ServerParameters,\n    session_params: ClientSessionParameters | None = None,\n) -&gt; ClientSession\n</code></pre> <p>Connects to a single MCP server.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def connect_to_server(\n    self,\n    server_params: ServerParameters,\n    session_params: ClientSessionParameters | None = None,\n) -&gt; mcp.ClientSession:\n    \"\"\"Connects to a single MCP server.\"\"\"\n    server_info, session = await self._establish_session(server_params, session_params or ClientSessionParameters())\n    return await self.connect_with_session(server_info, session)\n</code></pre>"},{"location":"api/#mcp.StdioServerParameters","title":"StdioServerParameters","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/mcp/client/stdio/__init__.py</code> <pre><code>class StdioServerParameters(BaseModel):\n    command: str\n    \"\"\"The executable to run to start the server.\"\"\"\n\n    args: list[str] = Field(default_factory=list)\n    \"\"\"Command line arguments to pass to the executable.\"\"\"\n\n    env: dict[str, str] | None = None\n    \"\"\"\n    The environment to use when spawning the process.\n\n    If not specified, the result of get_default_environment() will be used.\n    \"\"\"\n\n    cwd: str | Path | None = None\n    \"\"\"The working directory to use when spawning the process.\"\"\"\n\n    encoding: str = \"utf-8\"\n    \"\"\"\n    The text encoding used when sending/receiving messages to the server\n\n    defaults to utf-8\n    \"\"\"\n\n    encoding_error_handler: Literal[\"strict\", \"ignore\", \"replace\"] = \"strict\"\n    \"\"\"\n    The text encoding error handler.\n\n    See https://docs.python.org/3/library/codecs.html#codec-base-classes for\n    explanations of possible values\n    \"\"\"\n</code></pre>"},{"location":"api/#mcp.StdioServerParameters.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command: str\n</code></pre> <p>The executable to run to start the server.</p>"},{"location":"api/#mcp.StdioServerParameters.args","title":"args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>args: list[str] = Field(default_factory=list)\n</code></pre> <p>Command line arguments to pass to the executable.</p>"},{"location":"api/#mcp.StdioServerParameters.env","title":"env  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>env: dict[str, str] | None = None\n</code></pre> <p>The environment to use when spawning the process.</p> <p>If not specified, the result of get_default_environment() will be used.</p>"},{"location":"api/#mcp.StdioServerParameters.cwd","title":"cwd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cwd: str | Path | None = None\n</code></pre> <p>The working directory to use when spawning the process.</p>"},{"location":"api/#mcp.StdioServerParameters.encoding","title":"encoding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding: str = 'utf-8'\n</code></pre> <p>The text encoding used when sending/receiving messages to the server</p> <p>defaults to utf-8</p>"},{"location":"api/#mcp.StdioServerParameters.encoding_error_handler","title":"encoding_error_handler  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding_error_handler: Literal[\n    \"strict\", \"ignore\", \"replace\"\n] = \"strict\"\n</code></pre> <p>The text encoding error handler.</p> <p>See https://docs.python.org/3/library/codecs.html#codec-base-classes for explanations of possible values</p>"},{"location":"api/#mcp.stdio_client","title":"stdio_client  <code>async</code>","text":"<pre><code>stdio_client(\n    server: StdioServerParameters, errlog: TextIO = stderr\n)\n</code></pre> <p>Client transport for stdio: this will connect to a server by spawning a process and communicating with it over stdin/stdout.</p> Source code in <code>src/mcp/client/stdio/__init__.py</code> <pre><code>@asynccontextmanager\nasync def stdio_client(server: StdioServerParameters, errlog: TextIO = sys.stderr):\n    \"\"\"\n    Client transport for stdio: this will connect to a server by spawning a\n    process and communicating with it over stdin/stdout.\n    \"\"\"\n    read_stream: MemoryObjectReceiveStream[SessionMessage | Exception]\n    read_stream_writer: MemoryObjectSendStream[SessionMessage | Exception]\n\n    write_stream: MemoryObjectSendStream[SessionMessage]\n    write_stream_reader: MemoryObjectReceiveStream[SessionMessage]\n\n    read_stream_writer, read_stream = anyio.create_memory_object_stream(0)\n    write_stream, write_stream_reader = anyio.create_memory_object_stream(0)\n\n    try:\n        command = _get_executable_command(server.command)\n\n        # Open process with stderr piped for capture\n        process = await _create_platform_compatible_process(\n            command=command,\n            args=server.args,\n            env=({**get_default_environment(), **server.env} if server.env is not None else get_default_environment()),\n            errlog=errlog,\n            cwd=server.cwd,\n        )\n    except OSError:\n        # Clean up streams if process creation fails\n        await read_stream.aclose()\n        await write_stream.aclose()\n        await read_stream_writer.aclose()\n        await write_stream_reader.aclose()\n        raise\n\n    async def stdout_reader():\n        assert process.stdout, \"Opened process is missing stdout\"\n\n        try:\n            async with read_stream_writer:\n                buffer = \"\"\n                async for chunk in TextReceiveStream(\n                    process.stdout,\n                    encoding=server.encoding,\n                    errors=server.encoding_error_handler,\n                ):\n                    lines = (buffer + chunk).split(\"\\n\")\n                    buffer = lines.pop()\n\n                    for line in lines:\n                        try:\n                            message = types.JSONRPCMessage.model_validate_json(line)\n                        except Exception as exc:  # pragma: no cover\n                            logger.exception(\"Failed to parse JSONRPC message from server\")\n                            await read_stream_writer.send(exc)\n                            continue\n\n                        session_message = SessionMessage(message)\n                        await read_stream_writer.send(session_message)\n        except anyio.ClosedResourceError:  # pragma: no cover\n            await anyio.lowlevel.checkpoint()\n\n    async def stdin_writer():\n        assert process.stdin, \"Opened process is missing stdin\"\n\n        try:\n            async with write_stream_reader:\n                async for session_message in write_stream_reader:\n                    json = session_message.message.model_dump_json(by_alias=True, exclude_none=True)\n                    await process.stdin.send(\n                        (json + \"\\n\").encode(\n                            encoding=server.encoding,\n                            errors=server.encoding_error_handler,\n                        )\n                    )\n        except anyio.ClosedResourceError:  # pragma: no cover\n            await anyio.lowlevel.checkpoint()\n\n    async with (\n        anyio.create_task_group() as tg,\n        process,\n    ):\n        tg.start_soon(stdout_reader)\n        tg.start_soon(stdin_writer)\n        try:\n            yield read_stream, write_stream\n        finally:\n            # MCP spec: stdio shutdown sequence\n            # 1. Close input stream to server\n            # 2. Wait for server to exit, or send SIGTERM if it doesn't exit in time\n            # 3. Send SIGKILL if still not exited\n            if process.stdin:  # pragma: no branch\n                try:\n                    await process.stdin.aclose()\n                except Exception:  # pragma: no cover\n                    # stdin might already be closed, which is fine\n                    pass\n\n            try:\n                # Give the process time to exit gracefully after stdin closes\n                with anyio.fail_after(PROCESS_TERMINATION_TIMEOUT):\n                    await process.wait()\n            except TimeoutError:\n                # Process didn't exit from stdin closure, use platform-specific termination\n                # which handles SIGTERM -&gt; SIGKILL escalation\n                await _terminate_process_tree(process)\n            except ProcessLookupError:  # pragma: no cover\n                # Process already exited, which is fine\n                pass\n            await read_stream.aclose()\n            await write_stream.aclose()\n            await read_stream_writer.aclose()\n            await write_stream_reader.aclose()\n</code></pre>"},{"location":"api/#mcp.ServerSession","title":"ServerSession","text":"<p>               Bases: <code>BaseSession[ServerRequest, ServerNotification, ServerResult, ClientRequest, ClientNotification]</code></p> Source code in <code>src/mcp/server/session.py</code> <pre><code>class ServerSession(\n    BaseSession[\n        types.ServerRequest,\n        types.ServerNotification,\n        types.ServerResult,\n        types.ClientRequest,\n        types.ClientNotification,\n    ]\n):\n    _initialized: InitializationState = InitializationState.NotInitialized\n    _client_params: types.InitializeRequestParams | None = None\n    _experimental_features: ExperimentalServerSessionFeatures | None = None\n\n    def __init__(\n        self,\n        read_stream: MemoryObjectReceiveStream[SessionMessage | Exception],\n        write_stream: MemoryObjectSendStream[SessionMessage],\n        init_options: InitializationOptions,\n        stateless: bool = False,\n    ) -&gt; None:\n        super().__init__(read_stream, write_stream, types.ClientRequest, types.ClientNotification)\n        self._initialization_state = (\n            InitializationState.Initialized if stateless else InitializationState.NotInitialized\n        )\n\n        self._init_options = init_options\n        self._incoming_message_stream_writer, self._incoming_message_stream_reader = anyio.create_memory_object_stream[\n            ServerRequestResponder\n        ](0)\n        self._exit_stack.push_async_callback(lambda: self._incoming_message_stream_reader.aclose())\n\n    @property\n    def client_params(self) -&gt; types.InitializeRequestParams | None:\n        return self._client_params  # pragma: no cover\n\n    @property\n    def experimental(self) -&gt; ExperimentalServerSessionFeatures:\n        \"\"\"Experimental APIs for server\u2192client task operations.\n\n        WARNING: These APIs are experimental and may change without notice.\n        \"\"\"\n        if self._experimental_features is None:\n            self._experimental_features = ExperimentalServerSessionFeatures(self)\n        return self._experimental_features\n\n    def check_client_capability(self, capability: types.ClientCapabilities) -&gt; bool:  # pragma: no cover\n        \"\"\"Check if the client supports a specific capability.\"\"\"\n        if self._client_params is None:\n            return False\n\n        client_caps = self._client_params.capabilities\n\n        if capability.roots is not None:\n            if client_caps.roots is None:\n                return False\n            if capability.roots.listChanged and not client_caps.roots.listChanged:\n                return False\n\n        if capability.sampling is not None:\n            if client_caps.sampling is None:\n                return False\n            if capability.sampling.context is not None and client_caps.sampling.context is None:\n                return False\n            if capability.sampling.tools is not None and client_caps.sampling.tools is None:\n                return False\n\n        if capability.elicitation is not None and client_caps.elicitation is None:\n            return False\n\n        if capability.experimental is not None:\n            if client_caps.experimental is None:\n                return False\n            for exp_key, exp_value in capability.experimental.items():\n                if exp_key not in client_caps.experimental or client_caps.experimental[exp_key] != exp_value:\n                    return False\n\n        if capability.tasks is not None:\n            if client_caps.tasks is None:\n                return False\n            if not check_tasks_capability(capability.tasks, client_caps.tasks):\n                return False\n\n        return True\n\n    async def _receive_loop(self) -&gt; None:\n        async with self._incoming_message_stream_writer:\n            await super()._receive_loop()\n\n    async def _received_request(self, responder: RequestResponder[types.ClientRequest, types.ServerResult]):\n        match responder.request.root:\n            case types.InitializeRequest(params=params):\n                requested_version = params.protocolVersion\n                self._initialization_state = InitializationState.Initializing\n                self._client_params = params\n                with responder:\n                    await responder.respond(\n                        types.ServerResult(\n                            types.InitializeResult(\n                                protocolVersion=requested_version\n                                if requested_version in SUPPORTED_PROTOCOL_VERSIONS\n                                else types.LATEST_PROTOCOL_VERSION,\n                                capabilities=self._init_options.capabilities,\n                                serverInfo=types.Implementation(\n                                    name=self._init_options.server_name,\n                                    version=self._init_options.server_version,\n                                    websiteUrl=self._init_options.website_url,\n                                    icons=self._init_options.icons,\n                                ),\n                                instructions=self._init_options.instructions,\n                            )\n                        )\n                    )\n                self._initialization_state = InitializationState.Initialized\n            case types.PingRequest():\n                # Ping requests are allowed at any time\n                pass\n            case _:\n                if self._initialization_state != InitializationState.Initialized:\n                    raise RuntimeError(\"Received request before initialization was complete\")\n\n    async def _received_notification(self, notification: types.ClientNotification) -&gt; None:\n        # Need this to avoid ASYNC910\n        await anyio.lowlevel.checkpoint()\n        match notification.root:\n            case types.InitializedNotification():\n                self._initialization_state = InitializationState.Initialized\n            case _:\n                if self._initialization_state != InitializationState.Initialized:  # pragma: no cover\n                    raise RuntimeError(\"Received notification before initialization was complete\")\n\n    async def send_log_message(\n        self,\n        level: types.LoggingLevel,\n        data: Any,\n        logger: str | None = None,\n        related_request_id: types.RequestId | None = None,\n    ) -&gt; None:\n        \"\"\"Send a log message notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.LoggingMessageNotification(\n                    params=types.LoggingMessageNotificationParams(\n                        level=level,\n                        data=data,\n                        logger=logger,\n                    ),\n                )\n            ),\n            related_request_id,\n        )\n\n    async def send_resource_updated(self, uri: AnyUrl) -&gt; None:  # pragma: no cover\n        \"\"\"Send a resource updated notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.ResourceUpdatedNotification(\n                    params=types.ResourceUpdatedNotificationParams(uri=uri),\n                )\n            )\n        )\n\n    @overload\n    async def create_message(\n        self,\n        messages: list[types.SamplingMessage],\n        *,\n        max_tokens: int,\n        system_prompt: str | None = None,\n        include_context: types.IncludeContext | None = None,\n        temperature: float | None = None,\n        stop_sequences: list[str] | None = None,\n        metadata: dict[str, Any] | None = None,\n        model_preferences: types.ModelPreferences | None = None,\n        tools: None = None,\n        tool_choice: types.ToolChoice | None = None,\n        related_request_id: types.RequestId | None = None,\n    ) -&gt; types.CreateMessageResult:\n        \"\"\"Overload: Without tools, returns single content.\"\"\"\n        ...\n\n    @overload\n    async def create_message(\n        self,\n        messages: list[types.SamplingMessage],\n        *,\n        max_tokens: int,\n        system_prompt: str | None = None,\n        include_context: types.IncludeContext | None = None,\n        temperature: float | None = None,\n        stop_sequences: list[str] | None = None,\n        metadata: dict[str, Any] | None = None,\n        model_preferences: types.ModelPreferences | None = None,\n        tools: list[types.Tool],\n        tool_choice: types.ToolChoice | None = None,\n        related_request_id: types.RequestId | None = None,\n    ) -&gt; types.CreateMessageResultWithTools:\n        \"\"\"Overload: With tools, returns array-capable content.\"\"\"\n        ...\n\n    async def create_message(\n        self,\n        messages: list[types.SamplingMessage],\n        *,\n        max_tokens: int,\n        system_prompt: str | None = None,\n        include_context: types.IncludeContext | None = None,\n        temperature: float | None = None,\n        stop_sequences: list[str] | None = None,\n        metadata: dict[str, Any] | None = None,\n        model_preferences: types.ModelPreferences | None = None,\n        tools: list[types.Tool] | None = None,\n        tool_choice: types.ToolChoice | None = None,\n        related_request_id: types.RequestId | None = None,\n    ) -&gt; types.CreateMessageResult | types.CreateMessageResultWithTools:\n        \"\"\"Send a sampling/create_message request.\n\n        Args:\n            messages: The conversation messages to send.\n            max_tokens: Maximum number of tokens to generate.\n            system_prompt: Optional system prompt.\n            include_context: Optional context inclusion setting.\n                Should only be set to \"thisServer\" or \"allServers\"\n                if the client has sampling.context capability.\n            temperature: Optional sampling temperature.\n            stop_sequences: Optional stop sequences.\n            metadata: Optional metadata to pass through to the LLM provider.\n            model_preferences: Optional model selection preferences.\n            tools: Optional list of tools the LLM can use during sampling.\n                Requires client to have sampling.tools capability.\n            tool_choice: Optional control over tool usage behavior.\n                Requires client to have sampling.tools capability.\n            related_request_id: Optional ID of a related request.\n\n        Returns:\n            The sampling result from the client.\n\n        Raises:\n            McpError: If tools are provided but client doesn't support them.\n            ValueError: If tool_use or tool_result message structure is invalid.\n        \"\"\"\n        client_caps = self._client_params.capabilities if self._client_params else None\n        validate_sampling_tools(client_caps, tools, tool_choice)\n        validate_tool_use_result_messages(messages)\n\n        request = types.ServerRequest(\n            types.CreateMessageRequest(\n                params=types.CreateMessageRequestParams(\n                    messages=messages,\n                    systemPrompt=system_prompt,\n                    includeContext=include_context,\n                    temperature=temperature,\n                    maxTokens=max_tokens,\n                    stopSequences=stop_sequences,\n                    metadata=metadata,\n                    modelPreferences=model_preferences,\n                    tools=tools,\n                    toolChoice=tool_choice,\n                ),\n            )\n        )\n        metadata_obj = ServerMessageMetadata(related_request_id=related_request_id)\n\n        # Use different result types based on whether tools are provided\n        if tools is not None:\n            return await self.send_request(\n                request=request,\n                result_type=types.CreateMessageResultWithTools,\n                metadata=metadata_obj,\n            )\n        return await self.send_request(\n            request=request,\n            result_type=types.CreateMessageResult,\n            metadata=metadata_obj,\n        )\n\n    async def list_roots(self) -&gt; types.ListRootsResult:\n        \"\"\"Send a roots/list request.\"\"\"\n        return await self.send_request(\n            types.ServerRequest(types.ListRootsRequest()),\n            types.ListRootsResult,\n        )\n\n    async def elicit(\n        self,\n        message: str,\n        requestedSchema: types.ElicitRequestedSchema,\n        related_request_id: types.RequestId | None = None,\n    ) -&gt; types.ElicitResult:\n        \"\"\"Send a form mode elicitation/create request.\n\n        Args:\n            message: The message to present to the user\n            requestedSchema: Schema defining the expected response structure\n            related_request_id: Optional ID of the request that triggered this elicitation\n\n        Returns:\n            The client's response\n\n        Note:\n            This method is deprecated in favor of elicit_form(). It remains for\n            backward compatibility but new code should use elicit_form().\n        \"\"\"\n        return await self.elicit_form(message, requestedSchema, related_request_id)\n\n    async def elicit_form(\n        self,\n        message: str,\n        requestedSchema: types.ElicitRequestedSchema,\n        related_request_id: types.RequestId | None = None,\n    ) -&gt; types.ElicitResult:\n        \"\"\"Send a form mode elicitation/create request.\n\n        Args:\n            message: The message to present to the user\n            requestedSchema: Schema defining the expected response structure\n            related_request_id: Optional ID of the request that triggered this elicitation\n\n        Returns:\n            The client's response with form data\n        \"\"\"\n        return await self.send_request(\n            types.ServerRequest(\n                types.ElicitRequest(\n                    params=types.ElicitRequestFormParams(\n                        message=message,\n                        requestedSchema=requestedSchema,\n                    ),\n                )\n            ),\n            types.ElicitResult,\n            metadata=ServerMessageMetadata(related_request_id=related_request_id),\n        )\n\n    async def elicit_url(\n        self,\n        message: str,\n        url: str,\n        elicitation_id: str,\n        related_request_id: types.RequestId | None = None,\n    ) -&gt; types.ElicitResult:\n        \"\"\"Send a URL mode elicitation/create request.\n\n        This directs the user to an external URL for out-of-band interactions\n        like OAuth flows, credential collection, or payment processing.\n\n        Args:\n            message: Human-readable explanation of why the interaction is needed\n            url: The URL the user should navigate to\n            elicitation_id: Unique identifier for tracking this elicitation\n            related_request_id: Optional ID of the request that triggered this elicitation\n\n        Returns:\n            The client's response indicating acceptance, decline, or cancellation\n        \"\"\"\n        return await self.send_request(\n            types.ServerRequest(\n                types.ElicitRequest(\n                    params=types.ElicitRequestURLParams(\n                        message=message,\n                        url=url,\n                        elicitationId=elicitation_id,\n                    ),\n                )\n            ),\n            types.ElicitResult,\n            metadata=ServerMessageMetadata(related_request_id=related_request_id),\n        )\n\n    async def send_ping(self) -&gt; types.EmptyResult:  # pragma: no cover\n        \"\"\"Send a ping request.\"\"\"\n        return await self.send_request(\n            types.ServerRequest(types.PingRequest()),\n            types.EmptyResult,\n        )\n\n    async def send_progress_notification(\n        self,\n        progress_token: str | int,\n        progress: float,\n        total: float | None = None,\n        message: str | None = None,\n        related_request_id: str | None = None,\n    ) -&gt; None:\n        \"\"\"Send a progress notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.ProgressNotification(\n                    params=types.ProgressNotificationParams(\n                        progressToken=progress_token,\n                        progress=progress,\n                        total=total,\n                        message=message,\n                    ),\n                )\n            ),\n            related_request_id,\n        )\n\n    async def send_resource_list_changed(self) -&gt; None:  # pragma: no cover\n        \"\"\"Send a resource list changed notification.\"\"\"\n        await self.send_notification(types.ServerNotification(types.ResourceListChangedNotification()))\n\n    async def send_tool_list_changed(self) -&gt; None:  # pragma: no cover\n        \"\"\"Send a tool list changed notification.\"\"\"\n        await self.send_notification(types.ServerNotification(types.ToolListChangedNotification()))\n\n    async def send_prompt_list_changed(self) -&gt; None:  # pragma: no cover\n        \"\"\"Send a prompt list changed notification.\"\"\"\n        await self.send_notification(types.ServerNotification(types.PromptListChangedNotification()))\n\n    async def send_elicit_complete(\n        self,\n        elicitation_id: str,\n        related_request_id: types.RequestId | None = None,\n    ) -&gt; None:\n        \"\"\"Send an elicitation completion notification.\n\n        This should be sent when a URL mode elicitation has been completed\n        out-of-band to inform the client that it may retry any requests\n        that were waiting for this elicitation.\n\n        Args:\n            elicitation_id: The unique identifier of the completed elicitation\n            related_request_id: Optional ID of the request that triggered this\n        \"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.ElicitCompleteNotification(\n                    params=types.ElicitCompleteNotificationParams(elicitationId=elicitation_id)\n                )\n            ),\n            related_request_id,\n        )\n\n    def _build_elicit_form_request(\n        self,\n        message: str,\n        requestedSchema: types.ElicitRequestedSchema,\n        related_task_id: str | None = None,\n        task: types.TaskMetadata | None = None,\n    ) -&gt; types.JSONRPCRequest:\n        \"\"\"Build a form mode elicitation request without sending it.\n\n        Args:\n            message: The message to present to the user\n            requestedSchema: Schema defining the expected response structure\n            related_task_id: If provided, adds io.modelcontextprotocol/related-task metadata\n            task: If provided, makes this a task-augmented request\n\n        Returns:\n            A JSONRPCRequest ready to be sent or queued\n        \"\"\"\n        params = types.ElicitRequestFormParams(\n            message=message,\n            requestedSchema=requestedSchema,\n            task=task,\n        )\n        params_data = params.model_dump(by_alias=True, mode=\"json\", exclude_none=True)\n\n        # Add related-task metadata if associated with a parent task\n        if related_task_id is not None:\n            # Defensive: model_dump() never includes _meta, but guard against future changes\n            if \"_meta\" not in params_data:  # pragma: no cover\n                params_data[\"_meta\"] = {}\n            params_data[\"_meta\"][RELATED_TASK_METADATA_KEY] = types.RelatedTaskMetadata(\n                taskId=related_task_id\n            ).model_dump(by_alias=True)\n\n        request_id = f\"task-{related_task_id}-{id(params)}\" if related_task_id else self._request_id\n        if related_task_id is None:\n            self._request_id += 1\n\n        return types.JSONRPCRequest(\n            jsonrpc=\"2.0\",\n            id=request_id,\n            method=\"elicitation/create\",\n            params=params_data,\n        )\n\n    def _build_elicit_url_request(\n        self,\n        message: str,\n        url: str,\n        elicitation_id: str,\n        related_task_id: str | None = None,\n    ) -&gt; types.JSONRPCRequest:\n        \"\"\"Build a URL mode elicitation request without sending it.\n\n        Args:\n            message: Human-readable explanation of why the interaction is needed\n            url: The URL the user should navigate to\n            elicitation_id: Unique identifier for tracking this elicitation\n            related_task_id: If provided, adds io.modelcontextprotocol/related-task metadata\n\n        Returns:\n            A JSONRPCRequest ready to be sent or queued\n        \"\"\"\n        params = types.ElicitRequestURLParams(\n            message=message,\n            url=url,\n            elicitationId=elicitation_id,\n        )\n        params_data = params.model_dump(by_alias=True, mode=\"json\", exclude_none=True)\n\n        # Add related-task metadata if associated with a parent task\n        if related_task_id is not None:\n            # Defensive: model_dump() never includes _meta, but guard against future changes\n            if \"_meta\" not in params_data:  # pragma: no cover\n                params_data[\"_meta\"] = {}\n            params_data[\"_meta\"][RELATED_TASK_METADATA_KEY] = types.RelatedTaskMetadata(\n                taskId=related_task_id\n            ).model_dump(by_alias=True)\n\n        request_id = f\"task-{related_task_id}-{id(params)}\" if related_task_id else self._request_id\n        if related_task_id is None:\n            self._request_id += 1\n\n        return types.JSONRPCRequest(\n            jsonrpc=\"2.0\",\n            id=request_id,\n            method=\"elicitation/create\",\n            params=params_data,\n        )\n\n    def _build_create_message_request(\n        self,\n        messages: list[types.SamplingMessage],\n        *,\n        max_tokens: int,\n        system_prompt: str | None = None,\n        include_context: types.IncludeContext | None = None,\n        temperature: float | None = None,\n        stop_sequences: list[str] | None = None,\n        metadata: dict[str, Any] | None = None,\n        model_preferences: types.ModelPreferences | None = None,\n        tools: list[types.Tool] | None = None,\n        tool_choice: types.ToolChoice | None = None,\n        related_task_id: str | None = None,\n        task: types.TaskMetadata | None = None,\n    ) -&gt; types.JSONRPCRequest:\n        \"\"\"Build a sampling/createMessage request without sending it.\n\n        Args:\n            messages: The conversation messages to send\n            max_tokens: Maximum number of tokens to generate\n            system_prompt: Optional system prompt\n            include_context: Optional context inclusion setting\n            temperature: Optional sampling temperature\n            stop_sequences: Optional stop sequences\n            metadata: Optional metadata to pass through to the LLM provider\n            model_preferences: Optional model selection preferences\n            tools: Optional list of tools the LLM can use during sampling\n            tool_choice: Optional control over tool usage behavior\n            related_task_id: If provided, adds io.modelcontextprotocol/related-task metadata\n            task: If provided, makes this a task-augmented request\n\n        Returns:\n            A JSONRPCRequest ready to be sent or queued\n        \"\"\"\n        params = types.CreateMessageRequestParams(\n            messages=messages,\n            systemPrompt=system_prompt,\n            includeContext=include_context,\n            temperature=temperature,\n            maxTokens=max_tokens,\n            stopSequences=stop_sequences,\n            metadata=metadata,\n            modelPreferences=model_preferences,\n            tools=tools,\n            toolChoice=tool_choice,\n            task=task,\n        )\n        params_data = params.model_dump(by_alias=True, mode=\"json\", exclude_none=True)\n\n        # Add related-task metadata if associated with a parent task\n        if related_task_id is not None:\n            # Defensive: model_dump() never includes _meta, but guard against future changes\n            if \"_meta\" not in params_data:  # pragma: no cover\n                params_data[\"_meta\"] = {}\n            params_data[\"_meta\"][RELATED_TASK_METADATA_KEY] = types.RelatedTaskMetadata(\n                taskId=related_task_id\n            ).model_dump(by_alias=True)\n\n        request_id = f\"task-{related_task_id}-{id(params)}\" if related_task_id else self._request_id\n        if related_task_id is None:\n            self._request_id += 1\n\n        return types.JSONRPCRequest(\n            jsonrpc=\"2.0\",\n            id=request_id,\n            method=\"sampling/createMessage\",\n            params=params_data,\n        )\n\n    async def send_message(self, message: SessionMessage) -&gt; None:\n        \"\"\"Send a raw session message.\n\n        This is primarily used by TaskResultHandler to deliver queued messages\n        (elicitation/sampling requests) to the client during task execution.\n\n        WARNING: This is a low-level experimental method that may change without\n        notice. Prefer using higher-level methods like send_notification() or\n        send_request() for normal operations.\n\n        Args:\n            message: The session message to send\n        \"\"\"\n        await self._write_stream.send(message)\n\n    async def _handle_incoming(self, req: ServerRequestResponder) -&gt; None:\n        await self._incoming_message_stream_writer.send(req)\n\n    @property\n    def incoming_messages(\n        self,\n    ) -&gt; MemoryObjectReceiveStream[ServerRequestResponder]:\n        return self._incoming_message_stream_reader\n</code></pre>"},{"location":"api/#mcp.ServerSession.experimental","title":"experimental  <code>property</code>","text":"<pre><code>experimental: ExperimentalServerSessionFeatures\n</code></pre> <p>Experimental APIs for server\u2192client task operations.</p> <p>WARNING: These APIs are experimental and may change without notice.</p>"},{"location":"api/#mcp.ServerSession.check_client_capability","title":"check_client_capability","text":"<pre><code>check_client_capability(\n    capability: ClientCapabilities,\n) -&gt; bool\n</code></pre> <p>Check if the client supports a specific capability.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>def check_client_capability(self, capability: types.ClientCapabilities) -&gt; bool:  # pragma: no cover\n    \"\"\"Check if the client supports a specific capability.\"\"\"\n    if self._client_params is None:\n        return False\n\n    client_caps = self._client_params.capabilities\n\n    if capability.roots is not None:\n        if client_caps.roots is None:\n            return False\n        if capability.roots.listChanged and not client_caps.roots.listChanged:\n            return False\n\n    if capability.sampling is not None:\n        if client_caps.sampling is None:\n            return False\n        if capability.sampling.context is not None and client_caps.sampling.context is None:\n            return False\n        if capability.sampling.tools is not None and client_caps.sampling.tools is None:\n            return False\n\n    if capability.elicitation is not None and client_caps.elicitation is None:\n        return False\n\n    if capability.experimental is not None:\n        if client_caps.experimental is None:\n            return False\n        for exp_key, exp_value in capability.experimental.items():\n            if exp_key not in client_caps.experimental or client_caps.experimental[exp_key] != exp_value:\n                return False\n\n    if capability.tasks is not None:\n        if client_caps.tasks is None:\n            return False\n        if not check_tasks_capability(capability.tasks, client_caps.tasks):\n            return False\n\n    return True\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_log_message","title":"send_log_message  <code>async</code>","text":"<pre><code>send_log_message(\n    level: LoggingLevel,\n    data: Any,\n    logger: str | None = None,\n    related_request_id: RequestId | None = None,\n) -&gt; None\n</code></pre> <p>Send a log message notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_log_message(\n    self,\n    level: types.LoggingLevel,\n    data: Any,\n    logger: str | None = None,\n    related_request_id: types.RequestId | None = None,\n) -&gt; None:\n    \"\"\"Send a log message notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.LoggingMessageNotification(\n                params=types.LoggingMessageNotificationParams(\n                    level=level,\n                    data=data,\n                    logger=logger,\n                ),\n            )\n        ),\n        related_request_id,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_resource_updated","title":"send_resource_updated  <code>async</code>","text":"<pre><code>send_resource_updated(uri: AnyUrl) -&gt; None\n</code></pre> <p>Send a resource updated notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_resource_updated(self, uri: AnyUrl) -&gt; None:  # pragma: no cover\n    \"\"\"Send a resource updated notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.ResourceUpdatedNotification(\n                params=types.ResourceUpdatedNotificationParams(uri=uri),\n            )\n        )\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.create_message","title":"create_message  <code>async</code>","text":"<pre><code>create_message(\n    messages: list[SamplingMessage],\n    *,\n    max_tokens: int,\n    system_prompt: str | None = None,\n    include_context: IncludeContext | None = None,\n    temperature: float | None = None,\n    stop_sequences: list[str] | None = None,\n    metadata: dict[str, Any] | None = None,\n    model_preferences: ModelPreferences | None = None,\n    tools: None = None,\n    tool_choice: ToolChoice | None = None,\n    related_request_id: RequestId | None = None\n) -&gt; CreateMessageResult\n</code></pre><pre><code>create_message(\n    messages: list[SamplingMessage],\n    *,\n    max_tokens: int,\n    system_prompt: str | None = None,\n    include_context: IncludeContext | None = None,\n    temperature: float | None = None,\n    stop_sequences: list[str] | None = None,\n    metadata: dict[str, Any] | None = None,\n    model_preferences: ModelPreferences | None = None,\n    tools: list[Tool],\n    tool_choice: ToolChoice | None = None,\n    related_request_id: RequestId | None = None\n) -&gt; CreateMessageResultWithTools\n</code></pre> <pre><code>create_message(\n    messages: list[SamplingMessage],\n    *,\n    max_tokens: int,\n    system_prompt: str | None = None,\n    include_context: IncludeContext | None = None,\n    temperature: float | None = None,\n    stop_sequences: list[str] | None = None,\n    metadata: dict[str, Any] | None = None,\n    model_preferences: ModelPreferences | None = None,\n    tools: list[Tool] | None = None,\n    tool_choice: ToolChoice | None = None,\n    related_request_id: RequestId | None = None\n) -&gt; CreateMessageResult | CreateMessageResultWithTools\n</code></pre> <p>Send a sampling/create_message request.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>list[SamplingMessage]</code> <p>The conversation messages to send.</p> required <code>max_tokens</code> <code>int</code> <p>Maximum number of tokens to generate.</p> required <code>system_prompt</code> <code>str | None</code> <p>Optional system prompt.</p> <code>None</code> <code>include_context</code> <code>IncludeContext | None</code> <p>Optional context inclusion setting. Should only be set to \"thisServer\" or \"allServers\" if the client has sampling.context capability.</p> <code>None</code> <code>temperature</code> <code>float | None</code> <p>Optional sampling temperature.</p> <code>None</code> <code>stop_sequences</code> <code>list[str] | None</code> <p>Optional stop sequences.</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Optional metadata to pass through to the LLM provider.</p> <code>None</code> <code>model_preferences</code> <code>ModelPreferences | None</code> <p>Optional model selection preferences.</p> <code>None</code> <code>tools</code> <code>list[Tool] | None</code> <p>Optional list of tools the LLM can use during sampling. Requires client to have sampling.tools capability.</p> <code>None</code> <code>tool_choice</code> <code>ToolChoice | None</code> <p>Optional control over tool usage behavior. Requires client to have sampling.tools capability.</p> <code>None</code> <code>related_request_id</code> <code>RequestId | None</code> <p>Optional ID of a related request.</p> <code>None</code> <p>Returns:</p> Type Description <code>CreateMessageResult | CreateMessageResultWithTools</code> <p>The sampling result from the client.</p> <p>Raises:</p> Type Description <code>McpError</code> <p>If tools are provided but client doesn't support them.</p> <code>ValueError</code> <p>If tool_use or tool_result message structure is invalid.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def create_message(\n    self,\n    messages: list[types.SamplingMessage],\n    *,\n    max_tokens: int,\n    system_prompt: str | None = None,\n    include_context: types.IncludeContext | None = None,\n    temperature: float | None = None,\n    stop_sequences: list[str] | None = None,\n    metadata: dict[str, Any] | None = None,\n    model_preferences: types.ModelPreferences | None = None,\n    tools: list[types.Tool] | None = None,\n    tool_choice: types.ToolChoice | None = None,\n    related_request_id: types.RequestId | None = None,\n) -&gt; types.CreateMessageResult | types.CreateMessageResultWithTools:\n    \"\"\"Send a sampling/create_message request.\n\n    Args:\n        messages: The conversation messages to send.\n        max_tokens: Maximum number of tokens to generate.\n        system_prompt: Optional system prompt.\n        include_context: Optional context inclusion setting.\n            Should only be set to \"thisServer\" or \"allServers\"\n            if the client has sampling.context capability.\n        temperature: Optional sampling temperature.\n        stop_sequences: Optional stop sequences.\n        metadata: Optional metadata to pass through to the LLM provider.\n        model_preferences: Optional model selection preferences.\n        tools: Optional list of tools the LLM can use during sampling.\n            Requires client to have sampling.tools capability.\n        tool_choice: Optional control over tool usage behavior.\n            Requires client to have sampling.tools capability.\n        related_request_id: Optional ID of a related request.\n\n    Returns:\n        The sampling result from the client.\n\n    Raises:\n        McpError: If tools are provided but client doesn't support them.\n        ValueError: If tool_use or tool_result message structure is invalid.\n    \"\"\"\n    client_caps = self._client_params.capabilities if self._client_params else None\n    validate_sampling_tools(client_caps, tools, tool_choice)\n    validate_tool_use_result_messages(messages)\n\n    request = types.ServerRequest(\n        types.CreateMessageRequest(\n            params=types.CreateMessageRequestParams(\n                messages=messages,\n                systemPrompt=system_prompt,\n                includeContext=include_context,\n                temperature=temperature,\n                maxTokens=max_tokens,\n                stopSequences=stop_sequences,\n                metadata=metadata,\n                modelPreferences=model_preferences,\n                tools=tools,\n                toolChoice=tool_choice,\n            ),\n        )\n    )\n    metadata_obj = ServerMessageMetadata(related_request_id=related_request_id)\n\n    # Use different result types based on whether tools are provided\n    if tools is not None:\n        return await self.send_request(\n            request=request,\n            result_type=types.CreateMessageResultWithTools,\n            metadata=metadata_obj,\n        )\n    return await self.send_request(\n        request=request,\n        result_type=types.CreateMessageResult,\n        metadata=metadata_obj,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.list_roots","title":"list_roots  <code>async</code>","text":"<pre><code>list_roots() -&gt; ListRootsResult\n</code></pre> <p>Send a roots/list request.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def list_roots(self) -&gt; types.ListRootsResult:\n    \"\"\"Send a roots/list request.\"\"\"\n    return await self.send_request(\n        types.ServerRequest(types.ListRootsRequest()),\n        types.ListRootsResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.elicit","title":"elicit  <code>async</code>","text":"<pre><code>elicit(\n    message: str,\n    requestedSchema: ElicitRequestedSchema,\n    related_request_id: RequestId | None = None,\n) -&gt; ElicitResult\n</code></pre> <p>Send a form mode elicitation/create request.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to present to the user</p> required <code>requestedSchema</code> <code>ElicitRequestedSchema</code> <p>Schema defining the expected response structure</p> required <code>related_request_id</code> <code>RequestId | None</code> <p>Optional ID of the request that triggered this elicitation</p> <code>None</code> <p>Returns:</p> Type Description <code>ElicitResult</code> <p>The client's response</p> Note <p>This method is deprecated in favor of elicit_form(). It remains for backward compatibility but new code should use elicit_form().</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def elicit(\n    self,\n    message: str,\n    requestedSchema: types.ElicitRequestedSchema,\n    related_request_id: types.RequestId | None = None,\n) -&gt; types.ElicitResult:\n    \"\"\"Send a form mode elicitation/create request.\n\n    Args:\n        message: The message to present to the user\n        requestedSchema: Schema defining the expected response structure\n        related_request_id: Optional ID of the request that triggered this elicitation\n\n    Returns:\n        The client's response\n\n    Note:\n        This method is deprecated in favor of elicit_form(). It remains for\n        backward compatibility but new code should use elicit_form().\n    \"\"\"\n    return await self.elicit_form(message, requestedSchema, related_request_id)\n</code></pre>"},{"location":"api/#mcp.ServerSession.elicit_form","title":"elicit_form  <code>async</code>","text":"<pre><code>elicit_form(\n    message: str,\n    requestedSchema: ElicitRequestedSchema,\n    related_request_id: RequestId | None = None,\n) -&gt; ElicitResult\n</code></pre> <p>Send a form mode elicitation/create request.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to present to the user</p> required <code>requestedSchema</code> <code>ElicitRequestedSchema</code> <p>Schema defining the expected response structure</p> required <code>related_request_id</code> <code>RequestId | None</code> <p>Optional ID of the request that triggered this elicitation</p> <code>None</code> <p>Returns:</p> Type Description <code>ElicitResult</code> <p>The client's response with form data</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def elicit_form(\n    self,\n    message: str,\n    requestedSchema: types.ElicitRequestedSchema,\n    related_request_id: types.RequestId | None = None,\n) -&gt; types.ElicitResult:\n    \"\"\"Send a form mode elicitation/create request.\n\n    Args:\n        message: The message to present to the user\n        requestedSchema: Schema defining the expected response structure\n        related_request_id: Optional ID of the request that triggered this elicitation\n\n    Returns:\n        The client's response with form data\n    \"\"\"\n    return await self.send_request(\n        types.ServerRequest(\n            types.ElicitRequest(\n                params=types.ElicitRequestFormParams(\n                    message=message,\n                    requestedSchema=requestedSchema,\n                ),\n            )\n        ),\n        types.ElicitResult,\n        metadata=ServerMessageMetadata(related_request_id=related_request_id),\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.elicit_url","title":"elicit_url  <code>async</code>","text":"<pre><code>elicit_url(\n    message: str,\n    url: str,\n    elicitation_id: str,\n    related_request_id: RequestId | None = None,\n) -&gt; ElicitResult\n</code></pre> <p>Send a URL mode elicitation/create request.</p> <p>This directs the user to an external URL for out-of-band interactions like OAuth flows, credential collection, or payment processing.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable explanation of why the interaction is needed</p> required <code>url</code> <code>str</code> <p>The URL the user should navigate to</p> required <code>elicitation_id</code> <code>str</code> <p>Unique identifier for tracking this elicitation</p> required <code>related_request_id</code> <code>RequestId | None</code> <p>Optional ID of the request that triggered this elicitation</p> <code>None</code> <p>Returns:</p> Type Description <code>ElicitResult</code> <p>The client's response indicating acceptance, decline, or cancellation</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def elicit_url(\n    self,\n    message: str,\n    url: str,\n    elicitation_id: str,\n    related_request_id: types.RequestId | None = None,\n) -&gt; types.ElicitResult:\n    \"\"\"Send a URL mode elicitation/create request.\n\n    This directs the user to an external URL for out-of-band interactions\n    like OAuth flows, credential collection, or payment processing.\n\n    Args:\n        message: Human-readable explanation of why the interaction is needed\n        url: The URL the user should navigate to\n        elicitation_id: Unique identifier for tracking this elicitation\n        related_request_id: Optional ID of the request that triggered this elicitation\n\n    Returns:\n        The client's response indicating acceptance, decline, or cancellation\n    \"\"\"\n    return await self.send_request(\n        types.ServerRequest(\n            types.ElicitRequest(\n                params=types.ElicitRequestURLParams(\n                    message=message,\n                    url=url,\n                    elicitationId=elicitation_id,\n                ),\n            )\n        ),\n        types.ElicitResult,\n        metadata=ServerMessageMetadata(related_request_id=related_request_id),\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_ping","title":"send_ping  <code>async</code>","text":"<pre><code>send_ping() -&gt; EmptyResult\n</code></pre> <p>Send a ping request.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_ping(self) -&gt; types.EmptyResult:  # pragma: no cover\n    \"\"\"Send a ping request.\"\"\"\n    return await self.send_request(\n        types.ServerRequest(types.PingRequest()),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_progress_notification","title":"send_progress_notification  <code>async</code>","text":"<pre><code>send_progress_notification(\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n    related_request_id: str | None = None,\n) -&gt; None\n</code></pre> <p>Send a progress notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_progress_notification(\n    self,\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n    related_request_id: str | None = None,\n) -&gt; None:\n    \"\"\"Send a progress notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.ProgressNotification(\n                params=types.ProgressNotificationParams(\n                    progressToken=progress_token,\n                    progress=progress,\n                    total=total,\n                    message=message,\n                ),\n            )\n        ),\n        related_request_id,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_resource_list_changed","title":"send_resource_list_changed  <code>async</code>","text":"<pre><code>send_resource_list_changed() -&gt; None\n</code></pre> <p>Send a resource list changed notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_resource_list_changed(self) -&gt; None:  # pragma: no cover\n    \"\"\"Send a resource list changed notification.\"\"\"\n    await self.send_notification(types.ServerNotification(types.ResourceListChangedNotification()))\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_tool_list_changed","title":"send_tool_list_changed  <code>async</code>","text":"<pre><code>send_tool_list_changed() -&gt; None\n</code></pre> <p>Send a tool list changed notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_tool_list_changed(self) -&gt; None:  # pragma: no cover\n    \"\"\"Send a tool list changed notification.\"\"\"\n    await self.send_notification(types.ServerNotification(types.ToolListChangedNotification()))\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_prompt_list_changed","title":"send_prompt_list_changed  <code>async</code>","text":"<pre><code>send_prompt_list_changed() -&gt; None\n</code></pre> <p>Send a prompt list changed notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_prompt_list_changed(self) -&gt; None:  # pragma: no cover\n    \"\"\"Send a prompt list changed notification.\"\"\"\n    await self.send_notification(types.ServerNotification(types.PromptListChangedNotification()))\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_elicit_complete","title":"send_elicit_complete  <code>async</code>","text":"<pre><code>send_elicit_complete(\n    elicitation_id: str,\n    related_request_id: RequestId | None = None,\n) -&gt; None\n</code></pre> <p>Send an elicitation completion notification.</p> <p>This should be sent when a URL mode elicitation has been completed out-of-band to inform the client that it may retry any requests that were waiting for this elicitation.</p> <p>Parameters:</p> Name Type Description Default <code>elicitation_id</code> <code>str</code> <p>The unique identifier of the completed elicitation</p> required <code>related_request_id</code> <code>RequestId | None</code> <p>Optional ID of the request that triggered this</p> <code>None</code> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_elicit_complete(\n    self,\n    elicitation_id: str,\n    related_request_id: types.RequestId | None = None,\n) -&gt; None:\n    \"\"\"Send an elicitation completion notification.\n\n    This should be sent when a URL mode elicitation has been completed\n    out-of-band to inform the client that it may retry any requests\n    that were waiting for this elicitation.\n\n    Args:\n        elicitation_id: The unique identifier of the completed elicitation\n        related_request_id: Optional ID of the request that triggered this\n    \"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.ElicitCompleteNotification(\n                params=types.ElicitCompleteNotificationParams(elicitationId=elicitation_id)\n            )\n        ),\n        related_request_id,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_message","title":"send_message  <code>async</code>","text":"<pre><code>send_message(message: SessionMessage) -&gt; None\n</code></pre> <p>Send a raw session message.</p> <p>This is primarily used by TaskResultHandler to deliver queued messages (elicitation/sampling requests) to the client during task execution.</p> <p>WARNING: This is a low-level experimental method that may change without notice. Prefer using higher-level methods like send_notification() or send_request() for normal operations.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>SessionMessage</code> <p>The session message to send</p> required Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_message(self, message: SessionMessage) -&gt; None:\n    \"\"\"Send a raw session message.\n\n    This is primarily used by TaskResultHandler to deliver queued messages\n    (elicitation/sampling requests) to the client during task execution.\n\n    WARNING: This is a low-level experimental method that may change without\n    notice. Prefer using higher-level methods like send_notification() or\n    send_request() for normal operations.\n\n    Args:\n        message: The session message to send\n    \"\"\"\n    await self._write_stream.send(message)\n</code></pre>"},{"location":"api/#mcp.stdio_server","title":"stdio_server  <code>async</code>","text":"<pre><code>stdio_server(\n    stdin: AsyncFile[str] | None = None,\n    stdout: AsyncFile[str] | None = None,\n)\n</code></pre> <p>Server transport for stdio: this communicates with an MCP client by reading from the current process' stdin and writing to stdout.</p> Source code in <code>src/mcp/server/stdio.py</code> <pre><code>@asynccontextmanager\nasync def stdio_server(\n    stdin: anyio.AsyncFile[str] | None = None,\n    stdout: anyio.AsyncFile[str] | None = None,\n):\n    \"\"\"\n    Server transport for stdio: this communicates with an MCP client by reading\n    from the current process' stdin and writing to stdout.\n    \"\"\"\n    # Purposely not using context managers for these, as we don't want to close\n    # standard process handles. Encoding of stdin/stdout as text streams on\n    # python is platform-dependent (Windows is particularly problematic), so we\n    # re-wrap the underlying binary stream to ensure UTF-8.\n    if not stdin:\n        stdin = anyio.wrap_file(TextIOWrapper(sys.stdin.buffer, encoding=\"utf-8\"))\n    if not stdout:\n        stdout = anyio.wrap_file(TextIOWrapper(sys.stdout.buffer, encoding=\"utf-8\"))\n\n    read_stream: MemoryObjectReceiveStream[SessionMessage | Exception]\n    read_stream_writer: MemoryObjectSendStream[SessionMessage | Exception]\n\n    write_stream: MemoryObjectSendStream[SessionMessage]\n    write_stream_reader: MemoryObjectReceiveStream[SessionMessage]\n\n    read_stream_writer, read_stream = anyio.create_memory_object_stream(0)\n    write_stream, write_stream_reader = anyio.create_memory_object_stream(0)\n\n    async def stdin_reader():\n        try:\n            async with read_stream_writer:\n                async for line in stdin:\n                    try:\n                        message = types.JSONRPCMessage.model_validate_json(line)\n                    except Exception as exc:  # pragma: no cover\n                        await read_stream_writer.send(exc)\n                        continue\n\n                    session_message = SessionMessage(message)\n                    await read_stream_writer.send(session_message)\n        except anyio.ClosedResourceError:  # pragma: no cover\n            await anyio.lowlevel.checkpoint()\n\n    async def stdout_writer():\n        try:\n            async with write_stream_reader:\n                async for session_message in write_stream_reader:\n                    json = session_message.message.model_dump_json(by_alias=True, exclude_none=True)\n                    await stdout.write(json + \"\\n\")\n                    await stdout.flush()\n        except anyio.ClosedResourceError:  # pragma: no cover\n            await anyio.lowlevel.checkpoint()\n\n    async with anyio.create_task_group() as tg:\n        tg.start_soon(stdin_reader)\n        tg.start_soon(stdout_writer)\n        yield read_stream, write_stream\n</code></pre>"},{"location":"api/#mcp.McpError","title":"McpError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception type raised when an error arrives over an MCP connection.</p> Source code in <code>src/mcp/shared/exceptions.py</code> <pre><code>class McpError(Exception):\n    \"\"\"\n    Exception type raised when an error arrives over an MCP connection.\n    \"\"\"\n\n    error: ErrorData\n\n    def __init__(self, error: ErrorData):\n        \"\"\"Initialize McpError.\"\"\"\n        super().__init__(error.message)\n        self.error = error\n</code></pre>"},{"location":"api/#mcp.McpError.__init__","title":"__init__","text":"<pre><code>__init__(error: ErrorData)\n</code></pre> <p>Initialize McpError.</p> Source code in <code>src/mcp/shared/exceptions.py</code> <pre><code>def __init__(self, error: ErrorData):\n    \"\"\"Initialize McpError.\"\"\"\n    super().__init__(error.message)\n    self.error = error\n</code></pre>"},{"location":"api/#mcp.UrlElicitationRequiredError","title":"UrlElicitationRequiredError","text":"<p>               Bases: <code>McpError</code></p> <p>Specialized error for when a tool requires URL mode elicitation(s) before proceeding.</p> <p>Servers can raise this error from tool handlers to indicate that the client must complete one or more URL elicitations before the request can be processed.</p> Example <p>raise UrlElicitationRequiredError([     ElicitRequestURLParams(         mode=\"url\",         message=\"Authorization required for your files\",         url=\"https://example.com/oauth/authorize\",         elicitationId=\"auth-001\"     ) ])</p> Source code in <code>src/mcp/shared/exceptions.py</code> <pre><code>class UrlElicitationRequiredError(McpError):\n    \"\"\"\n    Specialized error for when a tool requires URL mode elicitation(s) before proceeding.\n\n    Servers can raise this error from tool handlers to indicate that the client\n    must complete one or more URL elicitations before the request can be processed.\n\n    Example:\n        raise UrlElicitationRequiredError([\n            ElicitRequestURLParams(\n                mode=\"url\",\n                message=\"Authorization required for your files\",\n                url=\"https://example.com/oauth/authorize\",\n                elicitationId=\"auth-001\"\n            )\n        ])\n    \"\"\"\n\n    def __init__(\n        self,\n        elicitations: list[ElicitRequestURLParams],\n        message: str | None = None,\n    ):\n        \"\"\"Initialize UrlElicitationRequiredError.\"\"\"\n        if message is None:\n            message = f\"URL elicitation{'s' if len(elicitations) &gt; 1 else ''} required\"\n\n        self._elicitations = elicitations\n\n        error = ErrorData(\n            code=URL_ELICITATION_REQUIRED,\n            message=message,\n            data={\"elicitations\": [e.model_dump(by_alias=True, exclude_none=True) for e in elicitations]},\n        )\n        super().__init__(error)\n\n    @property\n    def elicitations(self) -&gt; list[ElicitRequestURLParams]:\n        \"\"\"The list of URL elicitations required before the request can proceed.\"\"\"\n        return self._elicitations\n\n    @classmethod\n    def from_error(cls, error: ErrorData) -&gt; UrlElicitationRequiredError:\n        \"\"\"Reconstruct from an ErrorData received over the wire.\"\"\"\n        if error.code != URL_ELICITATION_REQUIRED:\n            raise ValueError(f\"Expected error code {URL_ELICITATION_REQUIRED}, got {error.code}\")\n\n        data = cast(dict[str, Any], error.data or {})\n        raw_elicitations = cast(list[dict[str, Any]], data.get(\"elicitations\", []))\n        elicitations = [ElicitRequestURLParams.model_validate(e) for e in raw_elicitations]\n        return cls(elicitations, error.message)\n</code></pre>"},{"location":"api/#mcp.UrlElicitationRequiredError.__init__","title":"__init__","text":"<pre><code>__init__(\n    elicitations: list[ElicitRequestURLParams],\n    message: str | None = None,\n)\n</code></pre> <p>Initialize UrlElicitationRequiredError.</p> Source code in <code>src/mcp/shared/exceptions.py</code> <pre><code>def __init__(\n    self,\n    elicitations: list[ElicitRequestURLParams],\n    message: str | None = None,\n):\n    \"\"\"Initialize UrlElicitationRequiredError.\"\"\"\n    if message is None:\n        message = f\"URL elicitation{'s' if len(elicitations) &gt; 1 else ''} required\"\n\n    self._elicitations = elicitations\n\n    error = ErrorData(\n        code=URL_ELICITATION_REQUIRED,\n        message=message,\n        data={\"elicitations\": [e.model_dump(by_alias=True, exclude_none=True) for e in elicitations]},\n    )\n    super().__init__(error)\n</code></pre>"},{"location":"api/#mcp.UrlElicitationRequiredError.elicitations","title":"elicitations  <code>property</code>","text":"<pre><code>elicitations: list[ElicitRequestURLParams]\n</code></pre> <p>The list of URL elicitations required before the request can proceed.</p>"},{"location":"api/#mcp.UrlElicitationRequiredError.from_error","title":"from_error  <code>classmethod</code>","text":"<pre><code>from_error(error: ErrorData) -&gt; UrlElicitationRequiredError\n</code></pre> <p>Reconstruct from an ErrorData received over the wire.</p> Source code in <code>src/mcp/shared/exceptions.py</code> <pre><code>@classmethod\ndef from_error(cls, error: ErrorData) -&gt; UrlElicitationRequiredError:\n    \"\"\"Reconstruct from an ErrorData received over the wire.\"\"\"\n    if error.code != URL_ELICITATION_REQUIRED:\n        raise ValueError(f\"Expected error code {URL_ELICITATION_REQUIRED}, got {error.code}\")\n\n    data = cast(dict[str, Any], error.data or {})\n    raw_elicitations = cast(list[dict[str, Any]], data.get(\"elicitations\", []))\n    elicitations = [ElicitRequestURLParams.model_validate(e) for e in raw_elicitations]\n    return cls(elicitations, error.message)\n</code></pre>"},{"location":"api/#mcp.CallToolRequest","title":"CallToolRequest","text":"<p>               Bases: <code>Request[CallToolRequestParams, Literal['tools/call']]</code></p> <p>Used by the client to invoke a tool provided by the server.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CallToolRequest(Request[CallToolRequestParams, Literal[\"tools/call\"]]):\n    \"\"\"Used by the client to invoke a tool provided by the server.\"\"\"\n\n    method: Literal[\"tools/call\"] = \"tools/call\"\n    params: CallToolRequestParams\n</code></pre>"},{"location":"api/#mcp.ClientCapabilities","title":"ClientCapabilities","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capabilities a client may support.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ClientCapabilities(BaseModel):\n    \"\"\"Capabilities a client may support.\"\"\"\n\n    experimental: dict[str, dict[str, Any]] | None = None\n    \"\"\"Experimental, non-standard capabilities that the client supports.\"\"\"\n    sampling: SamplingCapability | None = None\n    \"\"\"\n    Present if the client supports sampling from an LLM.\n    Can contain fine-grained capabilities like context and tools support.\n    \"\"\"\n    elicitation: ElicitationCapability | None = None\n    \"\"\"Present if the client supports elicitation from the user.\"\"\"\n    roots: RootsCapability | None = None\n    \"\"\"Present if the client supports listing roots.\"\"\"\n    tasks: ClientTasksCapability | None = None\n    \"\"\"Present if the client supports task-augmented requests.\"\"\"\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ClientCapabilities.experimental","title":"experimental  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>experimental: dict[str, dict[str, Any]] | None = None\n</code></pre> <p>Experimental, non-standard capabilities that the client supports.</p>"},{"location":"api/#mcp.ClientCapabilities.sampling","title":"sampling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sampling: SamplingCapability | None = None\n</code></pre> <p>Present if the client supports sampling from an LLM. Can contain fine-grained capabilities like context and tools support.</p>"},{"location":"api/#mcp.ClientCapabilities.elicitation","title":"elicitation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>elicitation: ElicitationCapability | None = None\n</code></pre> <p>Present if the client supports elicitation from the user.</p>"},{"location":"api/#mcp.ClientCapabilities.roots","title":"roots  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>roots: RootsCapability | None = None\n</code></pre> <p>Present if the client supports listing roots.</p>"},{"location":"api/#mcp.ClientCapabilities.tasks","title":"tasks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tasks: ClientTasksCapability | None = None\n</code></pre> <p>Present if the client supports task-augmented requests.</p>"},{"location":"api/#mcp.CompleteRequest","title":"CompleteRequest","text":"<p>               Bases: <code>Request[CompleteRequestParams, Literal['completion/complete']]</code></p> <p>A request from the client to the server, to ask for completion options.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CompleteRequest(Request[CompleteRequestParams, Literal[\"completion/complete\"]]):\n    \"\"\"A request from the client to the server, to ask for completion options.\"\"\"\n\n    method: Literal[\"completion/complete\"] = \"completion/complete\"\n    params: CompleteRequestParams\n</code></pre>"},{"location":"api/#mcp.CreateMessageRequest","title":"CreateMessageRequest","text":"<p>               Bases: <code>Request[CreateMessageRequestParams, Literal['sampling/createMessage']]</code></p> <p>A request from the server to sample an LLM via the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CreateMessageRequest(Request[CreateMessageRequestParams, Literal[\"sampling/createMessage\"]]):\n    \"\"\"A request from the server to sample an LLM via the client.\"\"\"\n\n    method: Literal[\"sampling/createMessage\"] = \"sampling/createMessage\"\n    params: CreateMessageRequestParams\n</code></pre>"},{"location":"api/#mcp.CreateMessageResult","title":"CreateMessageResult","text":"<p>               Bases: <code>Result</code></p> <p>The client's response to a sampling/create_message request from the server.</p> <p>This is the backwards-compatible version that returns single content (no arrays). Used when the request does not include tools.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CreateMessageResult(Result):\n    \"\"\"The client's response to a sampling/create_message request from the server.\n\n    This is the backwards-compatible version that returns single content (no arrays).\n    Used when the request does not include tools.\n    \"\"\"\n\n    role: Role\n    \"\"\"The role of the message sender (typically 'assistant' for LLM responses).\"\"\"\n    content: SamplingContent\n    \"\"\"Response content. Single content block (text, image, or audio).\"\"\"\n    model: str\n    \"\"\"The name of the model that generated the message.\"\"\"\n    stopReason: StopReason | None = None\n    \"\"\"The reason why sampling stopped, if known.\"\"\"\n</code></pre>"},{"location":"api/#mcp.CreateMessageResult.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: Role\n</code></pre> <p>The role of the message sender (typically 'assistant' for LLM responses).</p>"},{"location":"api/#mcp.CreateMessageResult.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: SamplingContent\n</code></pre> <p>Response content. Single content block (text, image, or audio).</p>"},{"location":"api/#mcp.CreateMessageResult.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model: str\n</code></pre> <p>The name of the model that generated the message.</p>"},{"location":"api/#mcp.CreateMessageResult.stopReason","title":"stopReason  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stopReason: StopReason | None = None\n</code></pre> <p>The reason why sampling stopped, if known.</p>"},{"location":"api/#mcp.CreateMessageResultWithTools","title":"CreateMessageResultWithTools","text":"<p>               Bases: <code>Result</code></p> <p>The client's response to a sampling/create_message request when tools were provided.</p> <p>This version supports array content for tool use flows.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CreateMessageResultWithTools(Result):\n    \"\"\"The client's response to a sampling/create_message request when tools were provided.\n\n    This version supports array content for tool use flows.\n    \"\"\"\n\n    role: Role\n    \"\"\"The role of the message sender (typically 'assistant' for LLM responses).\"\"\"\n    content: SamplingMessageContentBlock | list[SamplingMessageContentBlock]\n    \"\"\"\n    Response content. May be a single content block or an array.\n    May include ToolUseContent if stopReason is 'toolUse'.\n    \"\"\"\n    model: str\n    \"\"\"The name of the model that generated the message.\"\"\"\n    stopReason: StopReason | None = None\n    \"\"\"\n    The reason why sampling stopped, if known.\n    'toolUse' indicates the model wants to use a tool.\n    \"\"\"\n\n    @property\n    def content_as_list(self) -&gt; list[SamplingMessageContentBlock]:\n        \"\"\"Returns the content as a list of content blocks, regardless of whether\n        it was originally a single block or a list.\"\"\"\n        return self.content if isinstance(self.content, list) else [self.content]\n</code></pre>"},{"location":"api/#mcp.CreateMessageResultWithTools.role","title":"role  <code>instance-attribute</code>","text":"<pre><code>role: Role\n</code></pre> <p>The role of the message sender (typically 'assistant' for LLM responses).</p>"},{"location":"api/#mcp.CreateMessageResultWithTools.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: (\n    SamplingMessageContentBlock\n    | list[SamplingMessageContentBlock]\n)\n</code></pre> <p>Response content. May be a single content block or an array. May include ToolUseContent if stopReason is 'toolUse'.</p>"},{"location":"api/#mcp.CreateMessageResultWithTools.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model: str\n</code></pre> <p>The name of the model that generated the message.</p>"},{"location":"api/#mcp.CreateMessageResultWithTools.stopReason","title":"stopReason  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stopReason: StopReason | None = None\n</code></pre> <p>The reason why sampling stopped, if known. 'toolUse' indicates the model wants to use a tool.</p>"},{"location":"api/#mcp.CreateMessageResultWithTools.content_as_list","title":"content_as_list  <code>property</code>","text":"<pre><code>content_as_list: list[SamplingMessageContentBlock]\n</code></pre> <p>Returns the content as a list of content blocks, regardless of whether it was originally a single block or a list.</p>"},{"location":"api/#mcp.ErrorData","title":"ErrorData","text":"<p>               Bases: <code>BaseModel</code></p> <p>Error information for JSON-RPC error responses.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ErrorData(BaseModel):\n    \"\"\"Error information for JSON-RPC error responses.\"\"\"\n\n    code: int\n    \"\"\"The error type that occurred.\"\"\"\n\n    message: str\n    \"\"\"\n    A short description of the error. The message SHOULD be limited to a concise single\n    sentence.\n    \"\"\"\n\n    data: Any | None = None\n    \"\"\"\n    Additional information about the error. The value of this member is defined by the\n    sender (e.g. detailed error information, nested errors etc.).\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ErrorData.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: int\n</code></pre> <p>The error type that occurred.</p>"},{"location":"api/#mcp.ErrorData.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str\n</code></pre> <p>A short description of the error. The message SHOULD be limited to a concise single sentence.</p>"},{"location":"api/#mcp.ErrorData.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: Any | None = None\n</code></pre> <p>Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).</p>"},{"location":"api/#mcp.GetPromptRequest","title":"GetPromptRequest","text":"<p>               Bases: <code>Request[GetPromptRequestParams, Literal['prompts/get']]</code></p> <p>Used by the client to get a prompt provided by the server.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class GetPromptRequest(Request[GetPromptRequestParams, Literal[\"prompts/get\"]]):\n    \"\"\"Used by the client to get a prompt provided by the server.\"\"\"\n\n    method: Literal[\"prompts/get\"] = \"prompts/get\"\n    params: GetPromptRequestParams\n</code></pre>"},{"location":"api/#mcp.GetPromptResult","title":"GetPromptResult","text":"<p>               Bases: <code>Result</code></p> <p>The server's response to a prompts/get request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class GetPromptResult(Result):\n    \"\"\"The server's response to a prompts/get request from the client.\"\"\"\n\n    description: str | None = None\n    \"\"\"An optional description for the prompt.\"\"\"\n    messages: list[PromptMessage]\n</code></pre>"},{"location":"api/#mcp.GetPromptResult.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>An optional description for the prompt.</p>"},{"location":"api/#mcp.Implementation","title":"Implementation","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>Describes the name and version of an MCP implementation.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class Implementation(BaseMetadata):\n    \"\"\"Describes the name and version of an MCP implementation.\"\"\"\n\n    version: str\n\n    websiteUrl: str | None = None\n    \"\"\"An optional URL of the website for this implementation.\"\"\"\n\n    icons: list[Icon] | None = None\n    \"\"\"An optional list of icons for this implementation.\"\"\"\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.Implementation.websiteUrl","title":"websiteUrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>websiteUrl: str | None = None\n</code></pre> <p>An optional URL of the website for this implementation.</p>"},{"location":"api/#mcp.Implementation.icons","title":"icons  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>icons: list[Icon] | None = None\n</code></pre> <p>An optional list of icons for this implementation.</p>"},{"location":"api/#mcp.InitializedNotification","title":"InitializedNotification","text":"<p>               Bases: <code>Notification[NotificationParams | None, Literal['notifications/initialized']]</code></p> <p>This notification is sent from the client to the server after initialization has finished.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class InitializedNotification(Notification[NotificationParams | None, Literal[\"notifications/initialized\"]]):\n    \"\"\"\n    This notification is sent from the client to the server after initialization has\n    finished.\n    \"\"\"\n\n    method: Literal[\"notifications/initialized\"] = \"notifications/initialized\"\n    params: NotificationParams | None = None\n</code></pre>"},{"location":"api/#mcp.InitializeRequest","title":"InitializeRequest","text":"<p>               Bases: <code>Request[InitializeRequestParams, Literal['initialize']]</code></p> <p>This request is sent from the client to the server when it first connects, asking it to begin initialization.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class InitializeRequest(Request[InitializeRequestParams, Literal[\"initialize\"]]):\n    \"\"\"\n    This request is sent from the client to the server when it first connects, asking it\n    to begin initialization.\n    \"\"\"\n\n    method: Literal[\"initialize\"] = \"initialize\"\n    params: InitializeRequestParams\n</code></pre>"},{"location":"api/#mcp.InitializeResult","title":"InitializeResult","text":"<p>               Bases: <code>Result</code></p> <p>After receiving an initialize request from the client, the server sends this.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class InitializeResult(Result):\n    \"\"\"After receiving an initialize request from the client, the server sends this.\"\"\"\n\n    protocolVersion: str | int\n    \"\"\"The version of the Model Context Protocol that the server wants to use.\"\"\"\n    capabilities: ServerCapabilities\n    serverInfo: Implementation\n    instructions: str | None = None\n    \"\"\"Instructions describing how to use the server and its features.\"\"\"\n</code></pre>"},{"location":"api/#mcp.InitializeResult.protocolVersion","title":"protocolVersion  <code>instance-attribute</code>","text":"<pre><code>protocolVersion: str | int\n</code></pre> <p>The version of the Model Context Protocol that the server wants to use.</p>"},{"location":"api/#mcp.InitializeResult.instructions","title":"instructions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>instructions: str | None = None\n</code></pre> <p>Instructions describing how to use the server and its features.</p>"},{"location":"api/#mcp.JSONRPCError","title":"JSONRPCError","text":"<p>               Bases: <code>BaseModel</code></p> <p>A response to a request that indicates an error occurred.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class JSONRPCError(BaseModel):\n    \"\"\"A response to a request that indicates an error occurred.\"\"\"\n\n    jsonrpc: Literal[\"2.0\"]\n    id: str | int\n    error: ErrorData\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.JSONRPCRequest","title":"JSONRPCRequest","text":"<p>               Bases: <code>Request[dict[str, Any] | None, str]</code></p> <p>A request that expects a response.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class JSONRPCRequest(Request[dict[str, Any] | None, str]):\n    \"\"\"A request that expects a response.\"\"\"\n\n    jsonrpc: Literal[\"2.0\"]\n    id: RequestId\n    method: str\n    params: dict[str, Any] | None = None\n</code></pre>"},{"location":"api/#mcp.JSONRPCResponse","title":"JSONRPCResponse","text":"<p>               Bases: <code>BaseModel</code></p> <p>A successful (non-error) response to a request.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class JSONRPCResponse(BaseModel):\n    \"\"\"A successful (non-error) response to a request.\"\"\"\n\n    jsonrpc: Literal[\"2.0\"]\n    id: RequestId\n    result: dict[str, Any]\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ListPromptsRequest","title":"ListPromptsRequest","text":"<p>               Bases: <code>PaginatedRequest[Literal['prompts/list']]</code></p> <p>Sent from the client to request a list of prompts and prompt templates.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListPromptsRequest(PaginatedRequest[Literal[\"prompts/list\"]]):\n    \"\"\"Sent from the client to request a list of prompts and prompt templates.\"\"\"\n\n    method: Literal[\"prompts/list\"] = \"prompts/list\"\n</code></pre>"},{"location":"api/#mcp.ListPromptsResult","title":"ListPromptsResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a prompts/list request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListPromptsResult(PaginatedResult):\n    \"\"\"The server's response to a prompts/list request from the client.\"\"\"\n\n    prompts: list[Prompt]\n</code></pre>"},{"location":"api/#mcp.ListResourcesRequest","title":"ListResourcesRequest","text":"<p>               Bases: <code>PaginatedRequest[Literal['resources/list']]</code></p> <p>Sent from the client to request a list of resources the server has.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListResourcesRequest(PaginatedRequest[Literal[\"resources/list\"]]):\n    \"\"\"Sent from the client to request a list of resources the server has.\"\"\"\n\n    method: Literal[\"resources/list\"] = \"resources/list\"\n</code></pre>"},{"location":"api/#mcp.ListResourcesResult","title":"ListResourcesResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a resources/list request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListResourcesResult(PaginatedResult):\n    \"\"\"The server's response to a resources/list request from the client.\"\"\"\n\n    resources: list[Resource]\n</code></pre>"},{"location":"api/#mcp.ListToolsResult","title":"ListToolsResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a tools/list request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListToolsResult(PaginatedResult):\n    \"\"\"The server's response to a tools/list request from the client.\"\"\"\n\n    tools: list[Tool]\n</code></pre>"},{"location":"api/#mcp.LoggingMessageNotification","title":"LoggingMessageNotification","text":"<p>               Bases: <code>Notification[LoggingMessageNotificationParams, Literal['notifications/message']]</code></p> <p>Notification of a log message passed from server to client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class LoggingMessageNotification(Notification[LoggingMessageNotificationParams, Literal[\"notifications/message\"]]):\n    \"\"\"Notification of a log message passed from server to client.\"\"\"\n\n    method: Literal[\"notifications/message\"] = \"notifications/message\"\n    params: LoggingMessageNotificationParams\n</code></pre>"},{"location":"api/#mcp.Notification","title":"Notification","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[NotificationParamsT, MethodT]</code></p> <p>Base class for JSON-RPC notifications.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class Notification(BaseModel, Generic[NotificationParamsT, MethodT]):\n    \"\"\"Base class for JSON-RPC notifications.\"\"\"\n\n    method: MethodT\n    params: NotificationParamsT\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.PingRequest","title":"PingRequest","text":"<p>               Bases: <code>Request[RequestParams | None, Literal['ping']]</code></p> <p>A ping, issued by either the server or the client, to check that the other party is still alive.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class PingRequest(Request[RequestParams | None, Literal[\"ping\"]]):\n    \"\"\"\n    A ping, issued by either the server or the client, to check that the other party is\n    still alive.\n    \"\"\"\n\n    method: Literal[\"ping\"] = \"ping\"\n    params: RequestParams | None = None\n</code></pre>"},{"location":"api/#mcp.ProgressNotification","title":"ProgressNotification","text":"<p>               Bases: <code>Notification[ProgressNotificationParams, Literal['notifications/progress']]</code></p> <p>An out-of-band notification used to inform the receiver of a progress update for a long-running request.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ProgressNotification(Notification[ProgressNotificationParams, Literal[\"notifications/progress\"]]):\n    \"\"\"\n    An out-of-band notification used to inform the receiver of a progress update for a\n    long-running request.\n    \"\"\"\n\n    method: Literal[\"notifications/progress\"] = \"notifications/progress\"\n    params: ProgressNotificationParams\n</code></pre>"},{"location":"api/#mcp.PromptsCapability","title":"PromptsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for prompts operations.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class PromptsCapability(BaseModel):\n    \"\"\"Capability for prompts operations.\"\"\"\n\n    listChanged: bool | None = None\n    \"\"\"Whether this server supports notifications for changes to the prompt list.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.PromptsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the prompt list.</p>"},{"location":"api/#mcp.ReadResourceRequest","title":"ReadResourceRequest","text":"<p>               Bases: <code>Request[ReadResourceRequestParams, Literal['resources/read']]</code></p> <p>Sent from the client to the server, to read a specific resource URI.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ReadResourceRequest(Request[ReadResourceRequestParams, Literal[\"resources/read\"]]):\n    \"\"\"Sent from the client to the server, to read a specific resource URI.\"\"\"\n\n    method: Literal[\"resources/read\"] = \"resources/read\"\n    params: ReadResourceRequestParams\n</code></pre>"},{"location":"api/#mcp.ReadResourceResult","title":"ReadResourceResult","text":"<p>               Bases: <code>Result</code></p> <p>The server's response to a resources/read request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ReadResourceResult(Result):\n    \"\"\"The server's response to a resources/read request from the client.\"\"\"\n\n    contents: list[TextResourceContents | BlobResourceContents]\n</code></pre>"},{"location":"api/#mcp.Resource","title":"Resource","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>A known resource that the server is capable of reading.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class Resource(BaseMetadata):\n    \"\"\"A known resource that the server is capable of reading.\"\"\"\n\n    uri: Annotated[AnyUrl, UrlConstraints(host_required=False)]\n    \"\"\"The URI of this resource.\"\"\"\n    description: str | None = None\n    \"\"\"A description of what this resource represents.\"\"\"\n    mimeType: str | None = None\n    \"\"\"The MIME type of this resource, if known.\"\"\"\n    size: int | None = None\n    \"\"\"\n    The size of the raw resource content, in bytes (i.e., before base64 encoding\n    or any tokenization), if known.\n\n    This can be used by Hosts to display file sizes and estimate context window usage.\n    \"\"\"\n    icons: list[Icon] | None = None\n    \"\"\"An optional list of icons for this resource.\"\"\"\n    annotations: Annotations | None = None\n    meta: dict[str, Any] | None = Field(alias=\"_meta\", default=None)\n    \"\"\"\n    See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n    for notes on _meta usage.\n    \"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.Resource.uri","title":"uri  <code>instance-attribute</code>","text":"<pre><code>uri: Annotated[AnyUrl, UrlConstraints(host_required=False)]\n</code></pre> <p>The URI of this resource.</p>"},{"location":"api/#mcp.Resource.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>A description of what this resource represents.</p>"},{"location":"api/#mcp.Resource.mimeType","title":"mimeType  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mimeType: str | None = None\n</code></pre> <p>The MIME type of this resource, if known.</p>"},{"location":"api/#mcp.Resource.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: int | None = None\n</code></pre> <p>The size of the raw resource content, in bytes (i.e., before base64 encoding or any tokenization), if known.</p> <p>This can be used by Hosts to display file sizes and estimate context window usage.</p>"},{"location":"api/#mcp.Resource.icons","title":"icons  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>icons: list[Icon] | None = None\n</code></pre> <p>An optional list of icons for this resource.</p>"},{"location":"api/#mcp.Resource.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"api/#mcp.ResourcesCapability","title":"ResourcesCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for resources operations.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ResourcesCapability(BaseModel):\n    \"\"\"Capability for resources operations.\"\"\"\n\n    subscribe: bool | None = None\n    \"\"\"Whether this server supports subscribing to resource updates.\"\"\"\n    listChanged: bool | None = None\n    \"\"\"Whether this server supports notifications for changes to the resource list.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ResourcesCapability.subscribe","title":"subscribe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subscribe: bool | None = None\n</code></pre> <p>Whether this server supports subscribing to resource updates.</p>"},{"location":"api/#mcp.ResourcesCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the resource list.</p>"},{"location":"api/#mcp.ResourceUpdatedNotification","title":"ResourceUpdatedNotification","text":"<p>               Bases: <code>Notification[ResourceUpdatedNotificationParams, Literal['notifications/resources/updated']]</code></p> <p>A notification from the server to the client, informing it that a resource has changed and may need to be read again.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ResourceUpdatedNotification(\n    Notification[ResourceUpdatedNotificationParams, Literal[\"notifications/resources/updated\"]]\n):\n    \"\"\"\n    A notification from the server to the client, informing it that a resource has\n    changed and may need to be read again.\n    \"\"\"\n\n    method: Literal[\"notifications/resources/updated\"] = \"notifications/resources/updated\"\n    params: ResourceUpdatedNotificationParams\n</code></pre>"},{"location":"api/#mcp.RootsCapability","title":"RootsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for root operations.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class RootsCapability(BaseModel):\n    \"\"\"Capability for root operations.\"\"\"\n\n    listChanged: bool | None = None\n    \"\"\"Whether the client supports notifications for changes to the roots list.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.RootsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether the client supports notifications for changes to the roots list.</p>"},{"location":"api/#mcp.SamplingCapability","title":"SamplingCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Sampling capability structure, allowing fine-grained capability advertisement.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class SamplingCapability(BaseModel):\n    \"\"\"\n    Sampling capability structure, allowing fine-grained capability advertisement.\n    \"\"\"\n\n    context: SamplingContextCapability | None = None\n    \"\"\"\n    Present if the client supports non-'none' values for includeContext parameter.\n    SOFT-DEPRECATED: New implementations should use tools parameter instead.\n    \"\"\"\n    tools: SamplingToolsCapability | None = None\n    \"\"\"\n    Present if the client supports tools and toolChoice parameters in sampling requests.\n    Presence indicates full tool calling support during sampling.\n    \"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.SamplingCapability.context","title":"context  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>context: SamplingContextCapability | None = None\n</code></pre> <p>Present if the client supports non-'none' values for includeContext parameter. SOFT-DEPRECATED: New implementations should use tools parameter instead.</p>"},{"location":"api/#mcp.SamplingCapability.tools","title":"tools  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tools: SamplingToolsCapability | None = None\n</code></pre> <p>Present if the client supports tools and toolChoice parameters in sampling requests. Presence indicates full tool calling support during sampling.</p>"},{"location":"api/#mcp.SamplingContent","title":"SamplingContent  <code>module-attribute</code>","text":"<pre><code>SamplingContent: TypeAlias = (\n    TextContent | ImageContent | AudioContent\n)\n</code></pre> <p>Basic content types for sampling responses (without tool use). Used for backwards-compatible CreateMessageResult when tools are not used.</p>"},{"location":"api/#mcp.SamplingContextCapability","title":"SamplingContextCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for context inclusion during sampling.</p> <p>Indicates support for non-'none' values in the includeContext parameter. SOFT-DEPRECATED: New implementations should use tools parameter instead.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class SamplingContextCapability(BaseModel):\n    \"\"\"\n    Capability for context inclusion during sampling.\n\n    Indicates support for non-'none' values in the includeContext parameter.\n    SOFT-DEPRECATED: New implementations should use tools parameter instead.\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.SamplingMessage","title":"SamplingMessage","text":"<p>               Bases: <code>BaseModel</code></p> <p>Describes a message issued to or received from an LLM API.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class SamplingMessage(BaseModel):\n    \"\"\"Describes a message issued to or received from an LLM API.\"\"\"\n\n    role: Role\n    content: SamplingMessageContentBlock | list[SamplingMessageContentBlock]\n    \"\"\"\n    Message content. Can be a single content block or an array of content blocks\n    for multi-modal messages and tool interactions.\n    \"\"\"\n    meta: dict[str, Any] | None = Field(alias=\"_meta\", default=None)\n    \"\"\"\n    See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n    for notes on _meta usage.\n    \"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n\n    @property\n    def content_as_list(self) -&gt; list[SamplingMessageContentBlock]:\n        \"\"\"Returns the content as a list of content blocks, regardless of whether\n        it was originally a single block or a list.\"\"\"\n        return self.content if isinstance(self.content, list) else [self.content]\n</code></pre>"},{"location":"api/#mcp.SamplingMessage.content","title":"content  <code>instance-attribute</code>","text":"<pre><code>content: (\n    SamplingMessageContentBlock\n    | list[SamplingMessageContentBlock]\n)\n</code></pre> <p>Message content. Can be a single content block or an array of content blocks for multi-modal messages and tool interactions.</p>"},{"location":"api/#mcp.SamplingMessage.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"api/#mcp.SamplingMessage.content_as_list","title":"content_as_list  <code>property</code>","text":"<pre><code>content_as_list: list[SamplingMessageContentBlock]\n</code></pre> <p>Returns the content as a list of content blocks, regardless of whether it was originally a single block or a list.</p>"},{"location":"api/#mcp.SamplingMessageContentBlock","title":"SamplingMessageContentBlock  <code>module-attribute</code>","text":"<pre><code>SamplingMessageContentBlock: TypeAlias = (\n    TextContent\n    | ImageContent\n    | AudioContent\n    | ToolUseContent\n    | ToolResultContent\n)\n</code></pre> <p>Content block types allowed in sampling messages.</p>"},{"location":"api/#mcp.SamplingToolsCapability","title":"SamplingToolsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability indicating support for tool calling during sampling.</p> <p>When present in ClientCapabilities.sampling, indicates that the client supports the tools and toolChoice parameters in sampling requests.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class SamplingToolsCapability(BaseModel):\n    \"\"\"\n    Capability indicating support for tool calling during sampling.\n\n    When present in ClientCapabilities.sampling, indicates that the client\n    supports the tools and toolChoice parameters in sampling requests.\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ServerCapabilities","title":"ServerCapabilities","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capabilities that a server may support.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ServerCapabilities(BaseModel):\n    \"\"\"Capabilities that a server may support.\"\"\"\n\n    experimental: dict[str, dict[str, Any]] | None = None\n    \"\"\"Experimental, non-standard capabilities that the server supports.\"\"\"\n    logging: LoggingCapability | None = None\n    \"\"\"Present if the server supports sending log messages to the client.\"\"\"\n    prompts: PromptsCapability | None = None\n    \"\"\"Present if the server offers any prompt templates.\"\"\"\n    resources: ResourcesCapability | None = None\n    \"\"\"Present if the server offers any resources to read.\"\"\"\n    tools: ToolsCapability | None = None\n    \"\"\"Present if the server offers any tools to call.\"\"\"\n    completions: CompletionsCapability | None = None\n    \"\"\"Present if the server offers autocompletion suggestions for prompts and resources.\"\"\"\n    tasks: ServerTasksCapability | None = None\n    \"\"\"Present if the server supports task-augmented requests.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ServerCapabilities.experimental","title":"experimental  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>experimental: dict[str, dict[str, Any]] | None = None\n</code></pre> <p>Experimental, non-standard capabilities that the server supports.</p>"},{"location":"api/#mcp.ServerCapabilities.logging","title":"logging  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>logging: LoggingCapability | None = None\n</code></pre> <p>Present if the server supports sending log messages to the client.</p>"},{"location":"api/#mcp.ServerCapabilities.prompts","title":"prompts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prompts: PromptsCapability | None = None\n</code></pre> <p>Present if the server offers any prompt templates.</p>"},{"location":"api/#mcp.ServerCapabilities.resources","title":"resources  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resources: ResourcesCapability | None = None\n</code></pre> <p>Present if the server offers any resources to read.</p>"},{"location":"api/#mcp.ServerCapabilities.tools","title":"tools  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tools: ToolsCapability | None = None\n</code></pre> <p>Present if the server offers any tools to call.</p>"},{"location":"api/#mcp.ServerCapabilities.completions","title":"completions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>completions: CompletionsCapability | None = None\n</code></pre> <p>Present if the server offers autocompletion suggestions for prompts and resources.</p>"},{"location":"api/#mcp.ServerCapabilities.tasks","title":"tasks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tasks: ServerTasksCapability | None = None\n</code></pre> <p>Present if the server supports task-augmented requests.</p>"},{"location":"api/#mcp.SetLevelRequest","title":"SetLevelRequest","text":"<p>               Bases: <code>Request[SetLevelRequestParams, Literal['logging/setLevel']]</code></p> <p>A request from the client to the server, to enable or adjust logging.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class SetLevelRequest(Request[SetLevelRequestParams, Literal[\"logging/setLevel\"]]):\n    \"\"\"A request from the client to the server, to enable or adjust logging.\"\"\"\n\n    method: Literal[\"logging/setLevel\"] = \"logging/setLevel\"\n    params: SetLevelRequestParams\n</code></pre>"},{"location":"api/#mcp.SubscribeRequest","title":"SubscribeRequest","text":"<p>               Bases: <code>Request[SubscribeRequestParams, Literal['resources/subscribe']]</code></p> <p>Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class SubscribeRequest(Request[SubscribeRequestParams, Literal[\"resources/subscribe\"]]):\n    \"\"\"\n    Sent from the client to request resources/updated notifications from the server\n    whenever a particular resource changes.\n    \"\"\"\n\n    method: Literal[\"resources/subscribe\"] = \"resources/subscribe\"\n    params: SubscribeRequestParams\n</code></pre>"},{"location":"api/#mcp.Tool","title":"Tool","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>Definition for a tool the client can call.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class Tool(BaseMetadata):\n    \"\"\"Definition for a tool the client can call.\"\"\"\n\n    description: str | None = None\n    \"\"\"A human-readable description of the tool.\"\"\"\n    inputSchema: dict[str, Any]\n    \"\"\"A JSON Schema object defining the expected parameters for the tool.\"\"\"\n    outputSchema: dict[str, Any] | None = None\n    \"\"\"\n    An optional JSON Schema object defining the structure of the tool's output\n    returned in the structuredContent field of a CallToolResult.\n    \"\"\"\n    icons: list[Icon] | None = None\n    \"\"\"An optional list of icons for this tool.\"\"\"\n    annotations: ToolAnnotations | None = None\n    \"\"\"Optional additional tool information.\"\"\"\n    meta: dict[str, Any] | None = Field(alias=\"_meta\", default=None)\n    \"\"\"\n    See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n    for notes on _meta usage.\n    \"\"\"\n\n    execution: ToolExecution | None = None\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.Tool.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>A human-readable description of the tool.</p>"},{"location":"api/#mcp.Tool.inputSchema","title":"inputSchema  <code>instance-attribute</code>","text":"<pre><code>inputSchema: dict[str, Any]\n</code></pre> <p>A JSON Schema object defining the expected parameters for the tool.</p>"},{"location":"api/#mcp.Tool.outputSchema","title":"outputSchema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outputSchema: dict[str, Any] | None = None\n</code></pre> <p>An optional JSON Schema object defining the structure of the tool's output returned in the structuredContent field of a CallToolResult.</p>"},{"location":"api/#mcp.Tool.icons","title":"icons  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>icons: list[Icon] | None = None\n</code></pre> <p>An optional list of icons for this tool.</p>"},{"location":"api/#mcp.Tool.annotations","title":"annotations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>annotations: ToolAnnotations | None = None\n</code></pre> <p>Optional additional tool information.</p>"},{"location":"api/#mcp.Tool.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"api/#mcp.ToolChoice","title":"ToolChoice","text":"<p>               Bases: <code>BaseModel</code></p> <p>Controls tool usage behavior during sampling.</p> <p>Allows the server to specify whether and how the LLM should use tools in its response.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ToolChoice(BaseModel):\n    \"\"\"\n    Controls tool usage behavior during sampling.\n\n    Allows the server to specify whether and how the LLM should use tools\n    in its response.\n    \"\"\"\n\n    mode: Literal[\"auto\", \"required\", \"none\"] | None = None\n    \"\"\"\n    Controls when tools are used:\n    - \"auto\": Model decides whether to use tools (default)\n    - \"required\": Model MUST use at least one tool before completing\n    - \"none\": Model should not use tools\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ToolChoice.mode","title":"mode  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mode: Literal['auto', 'required', 'none'] | None = None\n</code></pre> <p>Controls when tools are used: - \"auto\": Model decides whether to use tools (default) - \"required\": Model MUST use at least one tool before completing - \"none\": Model should not use tools</p>"},{"location":"api/#mcp.ToolResultContent","title":"ToolResultContent","text":"<p>               Bases: <code>BaseModel</code></p> <p>Content representing the result of a tool execution.</p> <p>This content type appears in user messages as a response to a ToolUseContent from the assistant. It contains the output of executing the requested tool.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ToolResultContent(BaseModel):\n    \"\"\"\n    Content representing the result of a tool execution.\n\n    This content type appears in user messages as a response to a ToolUseContent\n    from the assistant. It contains the output of executing the requested tool.\n    \"\"\"\n\n    type: Literal[\"tool_result\"]\n    \"\"\"Discriminator for tool result content.\"\"\"\n\n    toolUseId: str\n    \"\"\"The unique identifier that corresponds to the tool call's id field.\"\"\"\n\n    content: list[\"ContentBlock\"] = []\n    \"\"\"\n    A list of content objects representing the tool result.\n    Defaults to empty list if not provided.\n    \"\"\"\n\n    structuredContent: dict[str, Any] | None = None\n    \"\"\"\n    Optional structured tool output that matches the tool's outputSchema (if defined).\n    \"\"\"\n\n    isError: bool | None = None\n    \"\"\"Whether the tool execution resulted in an error.\"\"\"\n\n    meta: dict[str, Any] | None = Field(alias=\"_meta\", default=None)\n    \"\"\"\n    See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n    for notes on _meta usage.\n    \"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ToolResultContent.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['tool_result']\n</code></pre> <p>Discriminator for tool result content.</p>"},{"location":"api/#mcp.ToolResultContent.toolUseId","title":"toolUseId  <code>instance-attribute</code>","text":"<pre><code>toolUseId: str\n</code></pre> <p>The unique identifier that corresponds to the tool call's id field.</p>"},{"location":"api/#mcp.ToolResultContent.content","title":"content  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>content: list[ContentBlock] = []\n</code></pre> <p>A list of content objects representing the tool result. Defaults to empty list if not provided.</p>"},{"location":"api/#mcp.ToolResultContent.structuredContent","title":"structuredContent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>structuredContent: dict[str, Any] | None = None\n</code></pre> <p>Optional structured tool output that matches the tool's outputSchema (if defined).</p>"},{"location":"api/#mcp.ToolResultContent.isError","title":"isError  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>isError: bool | None = None\n</code></pre> <p>Whether the tool execution resulted in an error.</p>"},{"location":"api/#mcp.ToolResultContent.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"api/#mcp.ToolsCapability","title":"ToolsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for tools operations.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ToolsCapability(BaseModel):\n    \"\"\"Capability for tools operations.\"\"\"\n\n    listChanged: bool | None = None\n    \"\"\"Whether this server supports notifications for changes to the tool list.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ToolsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the tool list.</p>"},{"location":"api/#mcp.ToolUseContent","title":"ToolUseContent","text":"<p>               Bases: <code>BaseModel</code></p> <p>Content representing an assistant's request to invoke a tool.</p> <p>This content type appears in assistant messages when the LLM wants to call a tool during sampling. The server should execute the tool and return a ToolResultContent in the next user message.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ToolUseContent(BaseModel):\n    \"\"\"\n    Content representing an assistant's request to invoke a tool.\n\n    This content type appears in assistant messages when the LLM wants to call a tool\n    during sampling. The server should execute the tool and return a ToolResultContent\n    in the next user message.\n    \"\"\"\n\n    type: Literal[\"tool_use\"]\n    \"\"\"Discriminator for tool use content.\"\"\"\n\n    name: str\n    \"\"\"The name of the tool to invoke. Must match a tool name from the request's tools array.\"\"\"\n\n    id: str\n    \"\"\"Unique identifier for this tool call, used to correlate with ToolResultContent.\"\"\"\n\n    input: dict[str, Any]\n    \"\"\"Arguments to pass to the tool. Must conform to the tool's inputSchema.\"\"\"\n\n    meta: dict[str, Any] | None = Field(alias=\"_meta\", default=None)\n    \"\"\"\n    See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n    for notes on _meta usage.\n    \"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ToolUseContent.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: Literal['tool_use']\n</code></pre> <p>Discriminator for tool use content.</p>"},{"location":"api/#mcp.ToolUseContent.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the tool to invoke. Must match a tool name from the request's tools array.</p>"},{"location":"api/#mcp.ToolUseContent.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: str\n</code></pre> <p>Unique identifier for this tool call, used to correlate with ToolResultContent.</p>"},{"location":"api/#mcp.ToolUseContent.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input: dict[str, Any]\n</code></pre> <p>Arguments to pass to the tool. Must conform to the tool's inputSchema.</p>"},{"location":"api/#mcp.ToolUseContent.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"api/#mcp.UnsubscribeRequest","title":"UnsubscribeRequest","text":"<p>               Bases: <code>Request[UnsubscribeRequestParams, Literal['resources/unsubscribe']]</code></p> <p>Sent from the client to request cancellation of resources/updated notifications from the server.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class UnsubscribeRequest(Request[UnsubscribeRequestParams, Literal[\"resources/unsubscribe\"]]):\n    \"\"\"\n    Sent from the client to request cancellation of resources/updated notifications from\n    the server.\n    \"\"\"\n\n    method: Literal[\"resources/unsubscribe\"] = \"resources/unsubscribe\"\n    params: UnsubscribeRequestParams\n</code></pre>"},{"location":"authorization/","title":"Authorization","text":""},{"location":"authorization/#authorization","title":"Authorization","text":"<p>Under Construction</p> <p>This page is currently being written. Check back soon for complete documentation.</p>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/#concepts","title":"Concepts","text":"<p>Under Construction</p> <p>This page is currently being written. Check back soon for complete documentation.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>The Python SDK is available on PyPI as <code>mcp</code> so installation is as simple as:</p> pipuv <pre><code>pip install mcp\n</code></pre> <pre><code>uv add mcp\n</code></pre> <p>The following dependencies are automatically installed:</p> <ul> <li><code>httpx</code>: HTTP client to handle HTTP Streamable and SSE transports.</li> <li><code>httpx-sse</code>: HTTP client to handle SSE transport.</li> <li><code>pydantic</code>: Types, JSON schema generation, data validation, and more.</li> <li><code>starlette</code>: Web framework used to build the HTTP transport endpoints.</li> <li><code>python-multipart</code>: Handle HTTP body parsing.</li> <li><code>sse-starlette</code>: Server-Sent Events for Starlette, used to build the SSE transport endpoint.</li> <li><code>pydantic-settings</code>: Settings management used in FastMCP.</li> <li><code>uvicorn</code>: ASGI server used to run the HTTP transport endpoints.</li> <li><code>jsonschema</code>: JSON schema validation.</li> <li><code>pywin32</code>: Windows specific dependencies for the CLI tools.</li> </ul> <p>This package has the following optional groups:</p> <ul> <li><code>cli</code>: Installs <code>typer</code> and <code>python-dotenv</code> for the MCP CLI tools.</li> </ul>"},{"location":"low-level-server/","title":"Low-Level Server","text":""},{"location":"low-level-server/#low-level-server","title":"Low-Level Server","text":"<p>Under Construction</p> <p>This page is currently being written. Check back soon for complete documentation.</p>"},{"location":"testing/","title":"Testing","text":""},{"location":"testing/#testing-mcp-servers","title":"Testing MCP Servers","text":"<p>If you call yourself a developer, you will want to test your MCP server. The Python SDK offers the <code>create_connected_server_and_client_session</code> function to create a session using an in-memory transport. I know, I know, the name is too long... We are working on improving it.</p> <p>Anyway, let's assume you have a simple server with a single tool:</p> server.py<pre><code>from mcp.server import FastMCP\n\napp = FastMCP(\"Calculator\")\n\n@app.tool()\ndef add(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers.\"\"\"  # (1)!\n    return a + b\n</code></pre> <ol> <li>The docstring is automatically added as the description of the tool.</li> </ol> <p>To run the below test, you'll need to install the following dependencies:</p> pipuv <pre><code>pip install inline-snapshot pytest\n</code></pre> <pre><code>uv add inline-snapshot pytest\n</code></pre> <p>Info</p> <p>I think <code>pytest</code> is a pretty standard testing framework, so I won't go into details here.</p> <p>The <code>inline-snapshot</code> is a library that allows you to take snapshots of the output of your tests. Which makes it easier to create tests for your server - you don't need to use it, but we are spreading the word for best practices.</p> test_server.py<pre><code>from collections.abc import AsyncGenerator\n\nimport pytest\nfrom inline_snapshot import snapshot\nfrom mcp.client.session import ClientSession\nfrom mcp.shared.memory import create_connected_server_and_client_session\nfrom mcp.types import CallToolResult, TextContent\n\nfrom server import app\n\n\n@pytest.fixture\ndef anyio_backend():  # (1)!\n    return \"asyncio\"\n\n\n@pytest.fixture\nasync def client_session() -&gt; AsyncGenerator[ClientSession]:\n    async with create_connected_server_and_client_session(app, raise_exceptions=True) as _session:\n        yield _session\n\n\n@pytest.mark.anyio\nasync def test_call_add_tool(client_session: ClientSession):\n    result = await client_session.call_tool(\"add\", {\"a\": 1, \"b\": 2})\n    assert result == snapshot(\n        CallToolResult(\n            content=[TextContent(type=\"text\", text=\"3\")],\n            structuredContent={\"result\": 3},\n        )\n    )\n</code></pre> <ol> <li>If you are using <code>trio</code>, you should set <code>\"trio\"</code> as the <code>anyio_backend</code>. Check more information in the anyio documentation.</li> </ol> <p>There you go! You can now extend your tests to cover more scenarios.</p>"},{"location":"experimental/","title":"Overview","text":""},{"location":"experimental/#experimental-features","title":"Experimental Features","text":"<p>Experimental APIs</p> <p>The features in this section are experimental and may change without notice. They track the evolving MCP specification and are not yet stable.</p> <p>This section documents experimental features in the MCP Python SDK. These features implement draft specifications that are still being refined.</p>"},{"location":"experimental/#available-experimental-features","title":"Available Experimental Features","text":""},{"location":"experimental/#tasks","title":"Tasks","text":"<p>Tasks enable asynchronous execution of MCP operations. Instead of waiting for a long-running operation to complete, the server returns a task reference immediately. Clients can then poll for status updates and retrieve results when ready.</p> <p>Tasks are useful for:</p> <ul> <li>Long-running computations that would otherwise block</li> <li>Batch operations that process many items</li> <li>Interactive workflows that require user input (elicitation) or LLM assistance (sampling)</li> </ul>"},{"location":"experimental/#using-experimental-apis","title":"Using Experimental APIs","text":"<p>Experimental features are accessed via the <code>.experimental</code> property:</p> <pre><code># Server-side\n@server.experimental.get_task()\nasync def handle_get_task(request: GetTaskRequest) -&gt; GetTaskResult:\n    ...\n\n# Client-side\nresult = await session.experimental.call_tool_as_task(\"tool_name\", {\"arg\": \"value\"})\n</code></pre>"},{"location":"experimental/#providing-feedback","title":"Providing Feedback","text":"<p>Since these features are experimental, feedback is especially valuable. If you encounter issues or have suggestions, please open an issue on the python-sdk repository.</p>"},{"location":"experimental/tasks-client/","title":"Client Usage","text":""},{"location":"experimental/tasks-client/#client-task-usage","title":"Client Task Usage","text":"<p>Experimental</p> <p>Tasks are an experimental feature. The API may change without notice.</p> <p>This guide covers calling task-augmented tools from clients, handling the <code>input_required</code> status, and advanced patterns like receiving task requests from servers.</p>"},{"location":"experimental/tasks-client/#quick-start","title":"Quick Start","text":"<p>Call a tool as a task and poll for the result:</p> <pre><code>from mcp.client.session import ClientSession\nfrom mcp.types import CallToolResult\n\nasync with ClientSession(read, write) as session:\n    await session.initialize()\n\n    # Call tool as task\n    result = await session.experimental.call_tool_as_task(\n        \"process_data\",\n        {\"input\": \"hello\"},\n        ttl=60000,\n    )\n    task_id = result.task.taskId\n\n    # Poll until complete\n    async for status in session.experimental.poll_task(task_id):\n        print(f\"Status: {status.status} - {status.statusMessage or ''}\")\n\n    # Get result\n    final = await session.experimental.get_task_result(task_id, CallToolResult)\n    print(f\"Result: {final.content[0].text}\")\n</code></pre>"},{"location":"experimental/tasks-client/#calling-tools-as-tasks","title":"Calling Tools as Tasks","text":"<p>Use <code>call_tool_as_task()</code> to invoke a tool with task augmentation:</p> <pre><code>result = await session.experimental.call_tool_as_task(\n    \"my_tool\",           # Tool name\n    {\"arg\": \"value\"},    # Arguments\n    ttl=60000,           # Time-to-live in milliseconds\n    meta={\"key\": \"val\"}, # Optional metadata\n)\n\ntask_id = result.task.taskId\nprint(f\"Task: {task_id}, Status: {result.task.status}\")\n</code></pre> <p>The response is a <code>CreateTaskResult</code> containing:</p> <ul> <li><code>task.taskId</code> - Unique identifier for polling</li> <li><code>task.status</code> - Initial status (usually <code>\"working\"</code>)</li> <li><code>task.pollInterval</code> - Suggested polling interval (milliseconds)</li> <li><code>task.ttl</code> - Time-to-live for results</li> <li><code>task.createdAt</code> - Creation timestamp</li> </ul>"},{"location":"experimental/tasks-client/#polling-with-poll_task","title":"Polling with poll_task","text":"<p>The <code>poll_task()</code> async iterator polls until the task reaches a terminal state:</p> <pre><code>async for status in session.experimental.poll_task(task_id):\n    print(f\"Status: {status.status}\")\n    if status.statusMessage:\n        print(f\"Progress: {status.statusMessage}\")\n</code></pre> <p>It automatically:</p> <ul> <li>Respects the server's suggested <code>pollInterval</code></li> <li>Stops when status is <code>completed</code>, <code>failed</code>, or <code>cancelled</code></li> <li>Yields each status for progress display</li> </ul>"},{"location":"experimental/tasks-client/#handling-input_required","title":"Handling input_required","text":"<p>When a task needs user input (elicitation), it transitions to <code>input_required</code>. You must call <code>get_task_result()</code> to receive and respond to the elicitation:</p> <pre><code>async for status in session.experimental.poll_task(task_id):\n    print(f\"Status: {status.status}\")\n\n    if status.status == \"input_required\":\n        # This delivers the elicitation and waits for completion\n        final = await session.experimental.get_task_result(task_id, CallToolResult)\n        break\n</code></pre> <p>The elicitation callback (set during session creation) handles the actual user interaction.</p>"},{"location":"experimental/tasks-client/#elicitation-callbacks","title":"Elicitation Callbacks","text":"<p>To handle elicitation requests from the server, provide a callback when creating the session:</p> <pre><code>from mcp.types import ElicitRequestParams, ElicitResult\n\nasync def handle_elicitation(context, params: ElicitRequestParams) -&gt; ElicitResult:\n    # Display the message to the user\n    print(f\"Server asks: {params.message}\")\n\n    # Collect user input (this is a simplified example)\n    response = input(\"Your response (y/n): \")\n    confirmed = response.lower() == \"y\"\n\n    return ElicitResult(\n        action=\"accept\",\n        content={\"confirm\": confirmed},\n    )\n\nasync with ClientSession(\n    read,\n    write,\n    elicitation_callback=handle_elicitation,\n) as session:\n    await session.initialize()\n    # ... call tasks that may require elicitation\n</code></pre>"},{"location":"experimental/tasks-client/#sampling-callbacks","title":"Sampling Callbacks","text":"<p>Similarly, handle sampling requests with a callback:</p> <pre><code>from mcp.types import CreateMessageRequestParams, CreateMessageResult, TextContent\n\nasync def handle_sampling(context, params: CreateMessageRequestParams) -&gt; CreateMessageResult:\n    # In a real implementation, call your LLM here\n    prompt = params.messages[-1].content.text if params.messages else \"\"\n\n    # Return a mock response\n    return CreateMessageResult(\n        role=\"assistant\",\n        content=TextContent(type=\"text\", text=f\"Response to: {prompt}\"),\n        model=\"my-model\",\n    )\n\nasync with ClientSession(\n    read,\n    write,\n    sampling_callback=handle_sampling,\n) as session:\n    # ...\n</code></pre>"},{"location":"experimental/tasks-client/#retrieving-results","title":"Retrieving Results","text":"<p>Once a task completes, retrieve the result:</p> <pre><code>if status.status == \"completed\":\n    result = await session.experimental.get_task_result(task_id, CallToolResult)\n    for content in result.content:\n        if hasattr(content, \"text\"):\n            print(content.text)\n\nelif status.status == \"failed\":\n    print(f\"Task failed: {status.statusMessage}\")\n\nelif status.status == \"cancelled\":\n    print(\"Task was cancelled\")\n</code></pre> <p>The result type matches the original request:</p> <ul> <li><code>tools/call</code> \u2192 <code>CallToolResult</code></li> <li><code>sampling/createMessage</code> \u2192 <code>CreateMessageResult</code></li> <li><code>elicitation/create</code> \u2192 <code>ElicitResult</code></li> </ul>"},{"location":"experimental/tasks-client/#cancellation","title":"Cancellation","text":"<p>Cancel a running task:</p> <pre><code>cancel_result = await session.experimental.cancel_task(task_id)\nprint(f\"Cancelled, status: {cancel_result.status}\")\n</code></pre> <p>Note: Cancellation is cooperative\u2014the server must check for and handle cancellation.</p>"},{"location":"experimental/tasks-client/#listing-tasks","title":"Listing Tasks","text":"<p>View all tasks on the server:</p> <pre><code>result = await session.experimental.list_tasks()\nfor task in result.tasks:\n    print(f\"{task.taskId}: {task.status}\")\n\n# Handle pagination\nwhile result.nextCursor:\n    result = await session.experimental.list_tasks(cursor=result.nextCursor)\n    for task in result.tasks:\n        print(f\"{task.taskId}: {task.status}\")\n</code></pre>"},{"location":"experimental/tasks-client/#advanced-client-as-task-receiver","title":"Advanced: Client as Task Receiver","text":"<p>Servers can send task-augmented requests to clients. This is useful when the server needs the client to perform async work (like complex sampling or user interaction).</p>"},{"location":"experimental/tasks-client/#declaring-client-capabilities","title":"Declaring Client Capabilities","text":"<p>Register task handlers to declare what task-augmented requests your client accepts:</p> <pre><code>from mcp.client.experimental.task_handlers import ExperimentalTaskHandlers\nfrom mcp.types import (\n    CreateTaskResult, GetTaskResult, GetTaskPayloadResult,\n    TaskMetadata, ElicitRequestParams,\n)\nfrom mcp.shared.experimental.tasks import InMemoryTaskStore\n\n# Client-side task store\nclient_store = InMemoryTaskStore()\n\nasync def handle_augmented_elicitation(context, params: ElicitRequestParams, task_metadata: TaskMetadata):\n    \"\"\"Handle task-augmented elicitation from server.\"\"\"\n    # Create a task for this elicitation\n    task = await client_store.create_task(task_metadata)\n\n    # Start async work (e.g., show UI, wait for user)\n    async def complete_elicitation():\n        # ... do async work ...\n        result = ElicitResult(action=\"accept\", content={\"confirm\": True})\n        await client_store.store_result(task.taskId, result)\n        await client_store.update_task(task.taskId, status=\"completed\")\n\n    context.session._task_group.start_soon(complete_elicitation)\n\n    # Return task reference immediately\n    return CreateTaskResult(task=task)\n\nasync def handle_get_task(context, params):\n    \"\"\"Handle tasks/get from server.\"\"\"\n    task = await client_store.get_task(params.taskId)\n    return GetTaskResult(\n        taskId=task.taskId,\n        status=task.status,\n        statusMessage=task.statusMessage,\n        createdAt=task.createdAt,\n        lastUpdatedAt=task.lastUpdatedAt,\n        ttl=task.ttl,\n        pollInterval=100,\n    )\n\nasync def handle_get_task_result(context, params):\n    \"\"\"Handle tasks/result from server.\"\"\"\n    result = await client_store.get_result(params.taskId)\n    return GetTaskPayloadResult.model_validate(result.model_dump())\n\ntask_handlers = ExperimentalTaskHandlers(\n    augmented_elicitation=handle_augmented_elicitation,\n    get_task=handle_get_task,\n    get_task_result=handle_get_task_result,\n)\n\nasync with ClientSession(\n    read,\n    write,\n    experimental_task_handlers=task_handlers,\n) as session:\n    # Client now accepts task-augmented elicitation from server\n    await session.initialize()\n</code></pre> <p>This enables flows where:</p> <ol> <li>Client calls a task-augmented tool</li> <li>Server's tool work calls <code>task.elicit_as_task()</code></li> <li>Client receives task-augmented elicitation</li> <li>Client creates its own task, does async work</li> <li>Server polls client's task</li> <li>Eventually both tasks complete</li> </ol>"},{"location":"experimental/tasks-client/#complete-example","title":"Complete Example","text":"<p>A client that handles all task scenarios:</p> <pre><code>import anyio\nfrom mcp.client.session import ClientSession\nfrom mcp.client.stdio import stdio_client\nfrom mcp.types import CallToolResult, ElicitRequestParams, ElicitResult\n\n\nasync def elicitation_callback(context, params: ElicitRequestParams) -&gt; ElicitResult:\n    print(f\"\\n[Elicitation] {params.message}\")\n    response = input(\"Confirm? (y/n): \")\n    return ElicitResult(action=\"accept\", content={\"confirm\": response.lower() == \"y\"})\n\n\nasync def main():\n    async with stdio_client(command=\"python\", args=[\"server.py\"]) as (read, write):\n        async with ClientSession(\n            read,\n            write,\n            elicitation_callback=elicitation_callback,\n        ) as session:\n            await session.initialize()\n\n            # List available tools\n            tools = await session.list_tools()\n            print(\"Tools:\", [t.name for t in tools.tools])\n\n            # Call a task-augmented tool\n            print(\"\\nCalling task tool...\")\n            result = await session.experimental.call_tool_as_task(\n                \"confirm_action\",\n                {\"action\": \"delete files\"},\n            )\n            task_id = result.task.taskId\n            print(f\"Task created: {task_id}\")\n\n            # Poll and handle input_required\n            async for status in session.experimental.poll_task(task_id):\n                print(f\"Status: {status.status}\")\n\n                if status.status == \"input_required\":\n                    final = await session.experimental.get_task_result(task_id, CallToolResult)\n                    print(f\"Result: {final.content[0].text}\")\n                    break\n\n            if status.status == \"completed\":\n                final = await session.experimental.get_task_result(task_id, CallToolResult)\n                print(f\"Result: {final.content[0].text}\")\n\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n</code></pre>"},{"location":"experimental/tasks-client/#error-handling","title":"Error Handling","text":"<p>Handle task errors gracefully:</p> <pre><code>from mcp.shared.exceptions import McpError\n\ntry:\n    result = await session.experimental.call_tool_as_task(\"my_tool\", args)\n    task_id = result.task.taskId\n\n    async for status in session.experimental.poll_task(task_id):\n        if status.status == \"failed\":\n            raise RuntimeError(f\"Task failed: {status.statusMessage}\")\n\n    final = await session.experimental.get_task_result(task_id, CallToolResult)\n\nexcept McpError as e:\n    print(f\"MCP error: {e.error.message}\")\nexcept Exception as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"experimental/tasks-client/#next-steps","title":"Next Steps","text":"<ul> <li>Server Implementation - Build task-supporting servers</li> <li>Tasks Overview - Review lifecycle and concepts</li> </ul>"},{"location":"experimental/tasks-server/","title":"Server Implementation","text":""},{"location":"experimental/tasks-server/#server-task-implementation","title":"Server Task Implementation","text":"<p>Experimental</p> <p>Tasks are an experimental feature. The API may change without notice.</p> <p>This guide covers implementing task support in MCP servers, from basic setup to advanced patterns like elicitation and sampling within tasks.</p>"},{"location":"experimental/tasks-server/#quick-start","title":"Quick Start","text":"<p>The simplest way to add task support:</p> <pre><code>from mcp.server import Server\nfrom mcp.server.experimental.task_context import ServerTaskContext\nfrom mcp.types import CallToolResult, CreateTaskResult, TextContent, Tool, ToolExecution, TASK_REQUIRED\n\nserver = Server(\"my-server\")\nserver.experimental.enable_tasks()  # Registers all task handlers automatically\n\n@server.list_tools()\nasync def list_tools():\n    return [\n        Tool(\n            name=\"process_data\",\n            description=\"Process data asynchronously\",\n            inputSchema={\"type\": \"object\", \"properties\": {\"input\": {\"type\": \"string\"}}},\n            execution=ToolExecution(taskSupport=TASK_REQUIRED),\n        )\n    ]\n\n@server.call_tool()\nasync def handle_tool(name: str, arguments: dict) -&gt; CallToolResult | CreateTaskResult:\n    if name == \"process_data\":\n        return await handle_process_data(arguments)\n    return CallToolResult(content=[TextContent(type=\"text\", text=f\"Unknown: {name}\")], isError=True)\n\nasync def handle_process_data(arguments: dict) -&gt; CreateTaskResult:\n    ctx = server.request_context\n    ctx.experimental.validate_task_mode(TASK_REQUIRED)\n\n    async def work(task: ServerTaskContext) -&gt; CallToolResult:\n        await task.update_status(\"Processing...\")\n        result = arguments.get(\"input\", \"\").upper()\n        return CallToolResult(content=[TextContent(type=\"text\", text=result)])\n\n    return await ctx.experimental.run_task(work)\n</code></pre> <p>That's it. <code>enable_tasks()</code> automatically:</p> <ul> <li>Creates an in-memory task store</li> <li>Registers handlers for <code>tasks/get</code>, <code>tasks/result</code>, <code>tasks/list</code>, <code>tasks/cancel</code></li> <li>Updates server capabilities</li> </ul>"},{"location":"experimental/tasks-server/#tool-declaration","title":"Tool Declaration","text":"<p>Tools declare task support via the <code>execution.taskSupport</code> field:</p> <pre><code>from mcp.types import Tool, ToolExecution, TASK_REQUIRED, TASK_OPTIONAL, TASK_FORBIDDEN\n\nTool(\n    name=\"my_tool\",\n    inputSchema={\"type\": \"object\"},\n    execution=ToolExecution(taskSupport=TASK_REQUIRED),  # or TASK_OPTIONAL, TASK_FORBIDDEN\n)\n</code></pre> Value Meaning <code>TASK_REQUIRED</code> Tool must be called as a task <code>TASK_OPTIONAL</code> Tool supports both sync and task execution <code>TASK_FORBIDDEN</code> Tool cannot be called as a task (default) <p>Validate the request matches your tool's requirements:</p> <pre><code>@server.call_tool()\nasync def handle_tool(name: str, arguments: dict):\n    ctx = server.request_context\n\n    if name == \"required_task_tool\":\n        ctx.experimental.validate_task_mode(TASK_REQUIRED)  # Raises if not task mode\n        return await handle_as_task(arguments)\n\n    elif name == \"optional_task_tool\":\n        if ctx.experimental.is_task:\n            return await handle_as_task(arguments)\n        else:\n            return handle_sync(arguments)\n</code></pre>"},{"location":"experimental/tasks-server/#the-run_task-pattern","title":"The run_task Pattern","text":"<p><code>run_task()</code> is the recommended way to execute task work:</p> <pre><code>async def handle_my_tool(arguments: dict) -&gt; CreateTaskResult:\n    ctx = server.request_context\n    ctx.experimental.validate_task_mode(TASK_REQUIRED)\n\n    async def work(task: ServerTaskContext) -&gt; CallToolResult:\n        # Your work here\n        return CallToolResult(content=[TextContent(type=\"text\", text=\"Done\")])\n\n    return await ctx.experimental.run_task(work)\n</code></pre> <p>What <code>run_task()</code> does:</p> <ol> <li>Creates a task in the store</li> <li>Spawns your work function in the background</li> <li>Returns <code>CreateTaskResult</code> immediately</li> <li>Auto-completes the task when your function returns</li> <li>Auto-fails the task if your function raises</li> </ol> <p>The <code>ServerTaskContext</code> provides:</p> <ul> <li><code>task.task_id</code> - The task identifier</li> <li><code>task.update_status(message)</code> - Update progress</li> <li><code>task.complete(result)</code> - Explicitly complete (usually automatic)</li> <li><code>task.fail(error)</code> - Explicitly fail</li> <li><code>task.is_cancelled</code> - Check if cancellation requested</li> </ul>"},{"location":"experimental/tasks-server/#status-updates","title":"Status Updates","text":"<p>Keep clients informed of progress:</p> <pre><code>async def work(task: ServerTaskContext) -&gt; CallToolResult:\n    await task.update_status(\"Starting...\")\n\n    for i, item in enumerate(items):\n        await task.update_status(f\"Processing {i+1}/{len(items)}\")\n        await process_item(item)\n\n    await task.update_status(\"Finalizing...\")\n    return CallToolResult(content=[TextContent(type=\"text\", text=\"Complete\")])\n</code></pre> <p>Status messages appear in <code>tasks/get</code> responses, letting clients show progress to users.</p>"},{"location":"experimental/tasks-server/#elicitation-within-tasks","title":"Elicitation Within Tasks","text":"<p>Tasks can request user input via elicitation. This transitions the task to <code>input_required</code> status.</p>"},{"location":"experimental/tasks-server/#form-elicitation","title":"Form Elicitation","text":"<p>Collect structured data from the user:</p> <pre><code>async def work(task: ServerTaskContext) -&gt; CallToolResult:\n    await task.update_status(\"Waiting for confirmation...\")\n\n    result = await task.elicit(\n        message=\"Delete these files?\",\n        requestedSchema={\n            \"type\": \"object\",\n            \"properties\": {\n                \"confirm\": {\"type\": \"boolean\"},\n                \"reason\": {\"type\": \"string\"},\n            },\n            \"required\": [\"confirm\"],\n        },\n    )\n\n    if result.action == \"accept\" and result.content.get(\"confirm\"):\n        # User confirmed\n        return CallToolResult(content=[TextContent(type=\"text\", text=\"Files deleted\")])\n    else:\n        # User declined or cancelled\n        return CallToolResult(content=[TextContent(type=\"text\", text=\"Cancelled\")])\n</code></pre>"},{"location":"experimental/tasks-server/#url-elicitation","title":"URL Elicitation","text":"<p>Direct users to external URLs for OAuth, payments, or other out-of-band flows:</p> <pre><code>async def work(task: ServerTaskContext) -&gt; CallToolResult:\n    await task.update_status(\"Waiting for OAuth...\")\n\n    result = await task.elicit_url(\n        message=\"Please authorize with GitHub\",\n        url=\"https://github.com/login/oauth/authorize?client_id=...\",\n        elicitation_id=\"oauth-github-123\",\n    )\n\n    if result.action == \"accept\":\n        # User completed OAuth flow\n        return CallToolResult(content=[TextContent(type=\"text\", text=\"Connected to GitHub\")])\n    else:\n        return CallToolResult(content=[TextContent(type=\"text\", text=\"OAuth cancelled\")])\n</code></pre>"},{"location":"experimental/tasks-server/#sampling-within-tasks","title":"Sampling Within Tasks","text":"<p>Tasks can request LLM completions from the client:</p> <pre><code>from mcp.types import SamplingMessage, TextContent\n\nasync def work(task: ServerTaskContext) -&gt; CallToolResult:\n    await task.update_status(\"Generating response...\")\n\n    result = await task.create_message(\n        messages=[\n            SamplingMessage(\n                role=\"user\",\n                content=TextContent(type=\"text\", text=\"Write a haiku about coding\"),\n            )\n        ],\n        max_tokens=100,\n    )\n\n    haiku = result.content.text if isinstance(result.content, TextContent) else \"Error\"\n    return CallToolResult(content=[TextContent(type=\"text\", text=haiku)])\n</code></pre> <p>Sampling supports additional parameters:</p> <pre><code>result = await task.create_message(\n    messages=[...],\n    max_tokens=500,\n    system_prompt=\"You are a helpful assistant\",\n    temperature=0.7,\n    stop_sequences=[\"\\n\\n\"],\n    model_preferences=ModelPreferences(hints=[ModelHint(name=\"claude-3\")]),\n)\n</code></pre>"},{"location":"experimental/tasks-server/#cancellation-support","title":"Cancellation Support","text":"<p>Check for cancellation in long-running work:</p> <pre><code>async def work(task: ServerTaskContext) -&gt; CallToolResult:\n    for i in range(1000):\n        if task.is_cancelled:\n            # Clean up and exit\n            return CallToolResult(content=[TextContent(type=\"text\", text=\"Cancelled\")])\n\n        await task.update_status(f\"Step {i}/1000\")\n        await process_step(i)\n\n    return CallToolResult(content=[TextContent(type=\"text\", text=\"Complete\")])\n</code></pre> <p>The SDK's default cancel handler updates the task status. Your work function should check <code>is_cancelled</code> periodically.</p>"},{"location":"experimental/tasks-server/#custom-task-store","title":"Custom Task Store","text":"<p>For production, implement <code>TaskStore</code> with persistent storage:</p> <pre><code>from mcp.shared.experimental.tasks.store import TaskStore\nfrom mcp.types import Task, TaskMetadata, Result\n\nclass RedisTaskStore(TaskStore):\n    def __init__(self, redis_client):\n        self.redis = redis_client\n\n    async def create_task(self, metadata: TaskMetadata, task_id: str | None = None) -&gt; Task:\n        # Create and persist task\n        ...\n\n    async def get_task(self, task_id: str) -&gt; Task | None:\n        # Retrieve task from Redis\n        ...\n\n    async def update_task(self, task_id: str, status: str | None = None, ...) -&gt; Task:\n        # Update and persist\n        ...\n\n    async def store_result(self, task_id: str, result: Result) -&gt; None:\n        # Store result in Redis\n        ...\n\n    async def get_result(self, task_id: str) -&gt; Result | None:\n        # Retrieve result\n        ...\n\n    # ... implement remaining methods\n</code></pre> <p>Use your custom store:</p> <pre><code>store = RedisTaskStore(redis_client)\nserver.experimental.enable_tasks(store=store)\n</code></pre>"},{"location":"experimental/tasks-server/#complete-example","title":"Complete Example","text":"<p>A server with multiple task-supporting tools:</p> <pre><code>from mcp.server import Server\nfrom mcp.server.experimental.task_context import ServerTaskContext\nfrom mcp.types import (\n    CallToolResult, CreateTaskResult, TextContent, Tool, ToolExecution,\n    SamplingMessage, TASK_REQUIRED,\n)\n\nserver = Server(\"task-demo\")\nserver.experimental.enable_tasks()\n\n\n@server.list_tools()\nasync def list_tools():\n    return [\n        Tool(\n            name=\"confirm_action\",\n            description=\"Requires user confirmation\",\n            inputSchema={\"type\": \"object\", \"properties\": {\"action\": {\"type\": \"string\"}}},\n            execution=ToolExecution(taskSupport=TASK_REQUIRED),\n        ),\n        Tool(\n            name=\"generate_text\",\n            description=\"Generate text via LLM\",\n            inputSchema={\"type\": \"object\", \"properties\": {\"prompt\": {\"type\": \"string\"}}},\n            execution=ToolExecution(taskSupport=TASK_REQUIRED),\n        ),\n    ]\n\n\nasync def handle_confirm_action(arguments: dict) -&gt; CreateTaskResult:\n    ctx = server.request_context\n    ctx.experimental.validate_task_mode(TASK_REQUIRED)\n\n    action = arguments.get(\"action\", \"unknown action\")\n\n    async def work(task: ServerTaskContext) -&gt; CallToolResult:\n        result = await task.elicit(\n            message=f\"Confirm: {action}?\",\n            requestedSchema={\n                \"type\": \"object\",\n                \"properties\": {\"confirm\": {\"type\": \"boolean\"}},\n                \"required\": [\"confirm\"],\n            },\n        )\n\n        if result.action == \"accept\" and result.content.get(\"confirm\"):\n            return CallToolResult(content=[TextContent(type=\"text\", text=f\"Executed: {action}\")])\n        return CallToolResult(content=[TextContent(type=\"text\", text=\"Cancelled\")])\n\n    return await ctx.experimental.run_task(work)\n\n\nasync def handle_generate_text(arguments: dict) -&gt; CreateTaskResult:\n    ctx = server.request_context\n    ctx.experimental.validate_task_mode(TASK_REQUIRED)\n\n    prompt = arguments.get(\"prompt\", \"Hello\")\n\n    async def work(task: ServerTaskContext) -&gt; CallToolResult:\n        await task.update_status(\"Generating...\")\n\n        result = await task.create_message(\n            messages=[SamplingMessage(role=\"user\", content=TextContent(type=\"text\", text=prompt))],\n            max_tokens=200,\n        )\n\n        text = result.content.text if isinstance(result.content, TextContent) else \"Error\"\n        return CallToolResult(content=[TextContent(type=\"text\", text=text)])\n\n    return await ctx.experimental.run_task(work)\n\n\n@server.call_tool()\nasync def handle_tool(name: str, arguments: dict) -&gt; CallToolResult | CreateTaskResult:\n    if name == \"confirm_action\":\n        return await handle_confirm_action(arguments)\n    elif name == \"generate_text\":\n        return await handle_generate_text(arguments)\n    return CallToolResult(content=[TextContent(type=\"text\", text=f\"Unknown: {name}\")], isError=True)\n</code></pre>"},{"location":"experimental/tasks-server/#error-handling-in-tasks","title":"Error Handling in Tasks","text":"<p>Tasks handle errors automatically, but you can also fail explicitly:</p> <pre><code>async def work(task: ServerTaskContext) -&gt; CallToolResult:\n    try:\n        result = await risky_operation()\n        return CallToolResult(content=[TextContent(type=\"text\", text=result)])\n    except PermissionError:\n        await task.fail(\"Access denied - insufficient permissions\")\n        raise\n    except TimeoutError:\n        await task.fail(\"Operation timed out after 30 seconds\")\n        raise\n</code></pre> <p>When <code>run_task()</code> catches an exception, it automatically:</p> <ol> <li>Marks the task as <code>failed</code></li> <li>Sets <code>statusMessage</code> to the exception message</li> <li>Propagates the exception (which is caught by the task group)</li> </ol> <p>For custom error messages, call <code>task.fail()</code> before raising.</p>"},{"location":"experimental/tasks-server/#http-transport-example","title":"HTTP Transport Example","text":"<p>For web applications, use the Streamable HTTP transport:</p> <pre><code>from collections.abc import AsyncIterator\nfrom contextlib import asynccontextmanager\n\nimport uvicorn\nfrom starlette.applications import Starlette\nfrom starlette.routing import Mount\n\nfrom mcp.server import Server\nfrom mcp.server.experimental.task_context import ServerTaskContext\nfrom mcp.server.streamable_http_manager import StreamableHTTPSessionManager\nfrom mcp.types import (\n    CallToolResult, CreateTaskResult, TextContent, Tool, ToolExecution, TASK_REQUIRED,\n)\n\n\nserver = Server(\"http-task-server\")\nserver.experimental.enable_tasks()\n\n\n@server.list_tools()\nasync def list_tools():\n    return [\n        Tool(\n            name=\"long_operation\",\n            description=\"A long-running operation\",\n            inputSchema={\"type\": \"object\", \"properties\": {\"duration\": {\"type\": \"number\"}}},\n            execution=ToolExecution(taskSupport=TASK_REQUIRED),\n        )\n    ]\n\n\nasync def handle_long_operation(arguments: dict) -&gt; CreateTaskResult:\n    ctx = server.request_context\n    ctx.experimental.validate_task_mode(TASK_REQUIRED)\n\n    duration = arguments.get(\"duration\", 5)\n\n    async def work(task: ServerTaskContext) -&gt; CallToolResult:\n        import anyio\n        for i in range(int(duration)):\n            await task.update_status(f\"Step {i+1}/{int(duration)}\")\n            await anyio.sleep(1)\n        return CallToolResult(content=[TextContent(type=\"text\", text=f\"Completed after {duration}s\")])\n\n    return await ctx.experimental.run_task(work)\n\n\n@server.call_tool()\nasync def handle_tool(name: str, arguments: dict) -&gt; CallToolResult | CreateTaskResult:\n    if name == \"long_operation\":\n        return await handle_long_operation(arguments)\n    return CallToolResult(content=[TextContent(type=\"text\", text=f\"Unknown: {name}\")], isError=True)\n\n\ndef create_app():\n    session_manager = StreamableHTTPSessionManager(app=server)\n\n    @asynccontextmanager\n    async def lifespan(app: Starlette) -&gt; AsyncIterator[None]:\n        async with session_manager.run():\n            yield\n\n    return Starlette(\n        routes=[Mount(\"/mcp\", app=session_manager.handle_request)],\n        lifespan=lifespan,\n    )\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(create_app(), host=\"127.0.0.1\", port=8000)\n</code></pre>"},{"location":"experimental/tasks-server/#testing-task-servers","title":"Testing Task Servers","text":"<p>Test task functionality with the SDK's testing utilities:</p> <pre><code>import pytest\nimport anyio\nfrom mcp.client.session import ClientSession\nfrom mcp.types import CallToolResult\n\n\n@pytest.mark.anyio\nasync def test_task_tool():\n    server_to_client_send, server_to_client_receive = anyio.create_memory_object_stream(10)\n    client_to_server_send, client_to_server_receive = anyio.create_memory_object_stream(10)\n\n    async def run_server():\n        await server.run(\n            client_to_server_receive,\n            server_to_client_send,\n            server.create_initialization_options(),\n        )\n\n    async def run_client():\n        async with ClientSession(server_to_client_receive, client_to_server_send) as session:\n            await session.initialize()\n\n            # Call the tool as a task\n            result = await session.experimental.call_tool_as_task(\"my_tool\", {\"arg\": \"value\"})\n            task_id = result.task.taskId\n            assert result.task.status == \"working\"\n\n            # Poll until complete\n            async for status in session.experimental.poll_task(task_id):\n                if status.status in (\"completed\", \"failed\"):\n                    break\n\n            # Get result\n            final = await session.experimental.get_task_result(task_id, CallToolResult)\n            assert len(final.content) &gt; 0\n\n    async with anyio.create_task_group() as tg:\n        tg.start_soon(run_server)\n        tg.start_soon(run_client)\n</code></pre>"},{"location":"experimental/tasks-server/#best-practices","title":"Best Practices","text":""},{"location":"experimental/tasks-server/#keep-work-functions-focused","title":"Keep Work Functions Focused","text":"<pre><code># Good: focused work function\nasync def work(task: ServerTaskContext) -&gt; CallToolResult:\n    await task.update_status(\"Validating...\")\n    validate_input(arguments)\n\n    await task.update_status(\"Processing...\")\n    result = await process_data(arguments)\n\n    return CallToolResult(content=[TextContent(type=\"text\", text=result)])\n</code></pre>"},{"location":"experimental/tasks-server/#check-cancellation-in-loops","title":"Check Cancellation in Loops","text":"<pre><code>async def work(task: ServerTaskContext) -&gt; CallToolResult:\n    results = []\n    for item in large_dataset:\n        if task.is_cancelled:\n            return CallToolResult(content=[TextContent(type=\"text\", text=\"Cancelled\")])\n\n        results.append(await process(item))\n\n    return CallToolResult(content=[TextContent(type=\"text\", text=str(results))])\n</code></pre>"},{"location":"experimental/tasks-server/#use-meaningful-status-messages","title":"Use Meaningful Status Messages","text":"<pre><code>async def work(task: ServerTaskContext) -&gt; CallToolResult:\n    await task.update_status(\"Connecting to database...\")\n    db = await connect()\n\n    await task.update_status(\"Fetching records (0/1000)...\")\n    for i, record in enumerate(records):\n        if i % 100 == 0:\n            await task.update_status(f\"Processing records ({i}/1000)...\")\n        await process(record)\n\n    await task.update_status(\"Finalizing results...\")\n    return CallToolResult(content=[TextContent(type=\"text\", text=\"Done\")])\n</code></pre>"},{"location":"experimental/tasks-server/#handle-elicitation-responses","title":"Handle Elicitation Responses","text":"<pre><code>async def work(task: ServerTaskContext) -&gt; CallToolResult:\n    result = await task.elicit(message=\"Continue?\", requestedSchema={...})\n\n    match result.action:\n        case \"accept\":\n            # User accepted, process content\n            return await process_accepted(result.content)\n        case \"decline\":\n            # User explicitly declined\n            return CallToolResult(content=[TextContent(type=\"text\", text=\"User declined\")])\n        case \"cancel\":\n            # User cancelled the elicitation\n            return CallToolResult(content=[TextContent(type=\"text\", text=\"Cancelled\")])\n</code></pre>"},{"location":"experimental/tasks-server/#next-steps","title":"Next Steps","text":"<ul> <li>Client Usage - Learn how clients interact with task servers</li> <li>Tasks Overview - Review lifecycle and concepts</li> </ul>"},{"location":"experimental/tasks/","title":"Introduction","text":""},{"location":"experimental/tasks/#tasks","title":"Tasks","text":"<p>Experimental</p> <p>Tasks are an experimental feature tracking the draft MCP specification. The API may change without notice.</p> <p>Tasks enable asynchronous request handling in MCP. Instead of blocking until an operation completes, the receiver creates a task, returns immediately, and the requestor polls for the result.</p>"},{"location":"experimental/tasks/#when-to-use-tasks","title":"When to Use Tasks","text":"<p>Tasks are designed for operations that:</p> <ul> <li>Take significant time (seconds to minutes)</li> <li>Need progress updates during execution</li> <li>Require user input mid-execution (elicitation, sampling)</li> <li>Should run without blocking the requestor</li> </ul> <p>Common use cases:</p> <ul> <li>Long-running data processing</li> <li>Multi-step workflows with user confirmation</li> <li>LLM-powered operations requiring sampling</li> <li>OAuth flows requiring user browser interaction</li> </ul>"},{"location":"experimental/tasks/#task-lifecycle","title":"Task Lifecycle","text":"<pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502   working   \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u2502            \u2502            \u2502\n              \u25bc            \u25bc            \u25bc\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502 completed  \u2502  \u2502  failed   \u2502  \u2502 cancelled \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n              \u25b2\n              \u2502\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502 input_required  \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n              \u2502                \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Status Description <code>working</code> Task is being processed <code>input_required</code> Receiver needs input from requestor (elicitation/sampling) <code>completed</code> Task finished successfully <code>failed</code> Task encountered an error <code>cancelled</code> Task was cancelled by requestor <p>Terminal states (<code>completed</code>, <code>failed</code>, <code>cancelled</code>) are final\u2014tasks cannot transition out of them.</p>"},{"location":"experimental/tasks/#bidirectional-flow","title":"Bidirectional Flow","text":"<p>Tasks work in both directions:</p> <p>Client \u2192 Server (most common):</p> <pre><code>Client                              Server\n  \u2502                                    \u2502\n  \u2502\u2500\u2500 tools/call (task) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502 Creates task\n  \u2502&lt;\u2500\u2500 CreateTaskResult \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n  \u2502                                    \u2502\n  \u2502\u2500\u2500 tasks/get \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u2502&lt;\u2500\u2500 status: working \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n  \u2502                                    \u2502 ... work continues ...\n  \u2502\u2500\u2500 tasks/get \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u2502&lt;\u2500\u2500 status: completed \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n  \u2502                                    \u2502\n  \u2502\u2500\u2500 tasks/result \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u2502&lt;\u2500\u2500 CallToolResult \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n</code></pre> <p>Server \u2192 Client (for elicitation/sampling):</p> <pre><code>Server                              Client\n  \u2502                                    \u2502\n  \u2502\u2500\u2500 elicitation/create (task) \u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502 Creates task\n  \u2502&lt;\u2500\u2500 CreateTaskResult \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n  \u2502                                    \u2502\n  \u2502\u2500\u2500 tasks/get \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u2502&lt;\u2500\u2500 status: working \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n  \u2502                                    \u2502 ... user interaction ...\n  \u2502\u2500\u2500 tasks/get \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u2502&lt;\u2500\u2500 status: completed \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n  \u2502                                    \u2502\n  \u2502\u2500\u2500 tasks/result \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u2502&lt;\u2500\u2500 ElicitResult \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n</code></pre>"},{"location":"experimental/tasks/#key-concepts","title":"Key Concepts","text":""},{"location":"experimental/tasks/#task-metadata","title":"Task Metadata","text":"<p>When augmenting a request with task execution, include <code>TaskMetadata</code>:</p> <pre><code>from mcp.types import TaskMetadata\n\ntask = TaskMetadata(ttl=60000)  # TTL in milliseconds\n</code></pre> <p>The <code>ttl</code> (time-to-live) specifies how long the task and result are retained after completion.</p>"},{"location":"experimental/tasks/#task-store","title":"Task Store","text":"<p>Servers persist task state in a <code>TaskStore</code>. The SDK provides <code>InMemoryTaskStore</code> for development:</p> <pre><code>from mcp.shared.experimental.tasks import InMemoryTaskStore\n\nstore = InMemoryTaskStore()\n</code></pre> <p>For production, implement <code>TaskStore</code> with a database or distributed cache.</p>"},{"location":"experimental/tasks/#capabilities","title":"Capabilities","text":"<p>Both servers and clients declare task support through capabilities:</p> <p>Server capabilities:</p> <ul> <li><code>tasks.requests.tools.call</code> - Server accepts task-augmented tool calls</li> </ul> <p>Client capabilities:</p> <ul> <li><code>tasks.requests.sampling.createMessage</code> - Client accepts task-augmented sampling</li> <li><code>tasks.requests.elicitation.create</code> - Client accepts task-augmented elicitation</li> </ul> <p>The SDK manages these automatically when you enable task support.</p>"},{"location":"experimental/tasks/#quick-example","title":"Quick Example","text":"<p>Server (simplified API):</p> <pre><code>from mcp.server import Server\nfrom mcp.server.experimental.task_context import ServerTaskContext\nfrom mcp.types import CallToolResult, TextContent, TASK_REQUIRED\n\nserver = Server(\"my-server\")\nserver.experimental.enable_tasks()  # One-line setup\n\n@server.call_tool()\nasync def handle_tool(name: str, arguments: dict):\n    ctx = server.request_context\n    ctx.experimental.validate_task_mode(TASK_REQUIRED)\n\n    async def work(task: ServerTaskContext):\n        await task.update_status(\"Processing...\")\n        # ... do work ...\n        return CallToolResult(content=[TextContent(type=\"text\", text=\"Done!\")])\n\n    return await ctx.experimental.run_task(work)\n</code></pre> <p>Client:</p> <pre><code>from mcp.client.session import ClientSession\nfrom mcp.types import CallToolResult\n\nasync with ClientSession(read, write) as session:\n    await session.initialize()\n\n    # Call tool as task\n    result = await session.experimental.call_tool_as_task(\"my_tool\", {\"arg\": \"value\"})\n    task_id = result.task.taskId\n\n    # Poll until done\n    async for status in session.experimental.poll_task(task_id):\n        print(f\"Status: {status.status}\")\n\n    # Get result\n    final = await session.experimental.get_task_result(task_id, CallToolResult)\n</code></pre>"},{"location":"experimental/tasks/#next-steps","title":"Next Steps","text":"<ul> <li>Server Implementation - Build task-supporting servers</li> <li>Client Usage - Call and poll tasks from clients</li> </ul>"}]}